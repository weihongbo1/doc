============================================================
=====                     JAVA知识                     =====
============================================================

Java内存：
静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
堆区： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。
堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组
成员变量全部存储与堆中，局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中

JVM：
JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区
程序计数器：一块较小的内存空间，它是当前线程所执行的字节码的行号指示器（么有规定任何OOM）
通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能，每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响
Java虚拟机栈：在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中

内存泄露：
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存
在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。
强   从来不会      对象的一般状态             jvm停止运行时终止
软   在内存不足时  联合ReferenceQueue构造有   内存不足时终止
                   效期短/内存大/生命周期长
                   的对象二级缓存
弱   在垃圾回收时  联合ReferenceQueue构造有   GC运行后终止
                   效期短/内存大/生命周期长
                   的对象一级缓存
虚   在垃圾回收时  联合ReferenceQueue构造跟   GC运行后终止
                   踪对象被垃圾回收期回收
虚引用,由于没办法通过虚引用来获取一个对象实例,为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

折半查找
        int low = 0;
        int high = sz.length - 1;

        while (low <= high) {
            int middle = (low + high) / 2;
            if(sz[middle] == key){
                return middle;
            }else if(sz[middle] > key){
                high = middle - 1;
            }else {
                low = middle + 1;
            }
        }
        return -1;
        
JDK 1.7特性
然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(\<>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码

JDK 1.8特性
java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：
Lambda 表达式，允许像对象一样传递匿名函数
Stream API，充分利用现代多核 CPU，可以写出很简洁的代码
Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用
扩展方法，现在，接口中可以有静态、默认方法。
重复注解，现在你可以将相同的注解在同一类型上使用多次。

for与foreach对比
对数组使用foreach语法，实质上转化成普通的for循环实现。而对List使用foreach语法，实质上为Iterator实现，与普通for循环实现完全不同。
所以，实现了RandomAccess的List（例如ArrayList），在遍历的时候使用for循环而不使用foreach。而对于没有实现RandomAccess的List（例如LinkedList），遍历使用Iterator更有效率一点。

foreach内部的实现机制其实就是使用的Iterator
ArrayList的头部插入了一个元素，使得你所有的元素都往后移动，于是你当前访问的第5个元素就会被重复访问。
java 认为在迭代过程中，容器应当保持不变。因此，java 容器中通常保留了一个域称为 modCount，每次你对容器修改，这个值就会加1。当你调用 iterator 方法时，返回的迭代器会记住当前的 modCount，随后迭代过程中会检查这个值，一旦发现这个值发生变化，就说明你对容器做了修改，就会抛异常。

for (Integer i : list) {
    System.out.println(i);
}
反编译之后：
Integer i;
for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(i)){
    i = (Integer)iterator.next();        
}
所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。



try中的return可以理解为保存了一份副本，即值或对象地址的保存，finally中的更改是更改原先值，return是返回副本
如果try中有return而finally中也有return，那么后者将会让前者失效！

自动装箱和自动拆箱：
Integer a = 10;  //实际执行的是Integer a = Integer.valueOf(10);
int b = a;       //实际执行的是int b = a.intValue();
拆箱操作：直接返回Integer内的数值
装箱操作：在i大于IntegerCache.low或者i小于IntegerCache.high时返回缓存的Integer对象，否则创建新的Integer对象。
         Integer在数据为[-128,127]之间时。使用了IntegerCache 返回缓存中对象的引用，否则new一个新的对象
Boolean内部有true&false两个静态变量，最后装箱得到的值都是这两个静态变量的引用。
Long&Integer&Short&Byte在数值为[-128,127]之间都有Cache。
Double&Float则都没有。

map中的移除操作
for (Iterator<Map.Entry<Integer, RouteListener>> it = map.entrySet().iterator(); it.hasNext()
        ; ) {
  Map.Entry<Integer, RouteListener> item = it.next();
  if (item.getValue().equals(listener)) {
    it.remove();
  }
}

synchronized 详解
互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问
可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。
原理：
每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。
2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.
3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。
执行monitorexit的线程必须是objectref所对应的monitor的所有者。
指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 
当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。

（其实wait/notify等方法也依赖于monitor对象，同步的块或者方法中才能调用wait/notify等方法）


对象锁：在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。
类锁：在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁

在同一对象的情况下，synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法获取的锁是同一个锁，即该类的对象的对象锁
两个线程访问不同对象的 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法是异步的，同一个类的不同对象的对象锁互不干扰。
在同一对象的情况下，synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法的行为一致。
两个线程访问不同对象的 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法还是同步的，类中 synchronized(类.class) {} 代码块和 synchronized 修饰静态方法获取的锁是类锁。对于同一个类的不同对象的类锁是同一个。
synchronized 修饰静态方法和 synchronized 修饰非静态方法是异步的，对于 synchronized(类.class) {} 代码块和 synchronized(this|object) {} 代码块也是一样的。所以对象锁和类锁是独立的，互不干扰

1、synchronized关键字不能继承。对于父类中的 synchronized 修饰方法，子类在覆盖该方法时，默认情况下不是同步的，必须显示的使用 synchronized 关键字修饰才行。
2、在定义接口方法时不能使用synchronized关键字。
3、构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。

synchronized 无法中断一个正在等候获得锁的线程，也无法通过投票得到锁
ReentrantLock 拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性

HashMap
HashMap：if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
在JDK8中，当链表长度达到8，会转化成红黑树，以提升它的查询、插入效率
当HashMap的容量达到threshold域值时，就会触发扩容。扩容前后，哈希桶的长度一定会是2的次方。
这样在根据key的hash值寻找对应的哈希桶时，可以用位运算替代取余操作，更加高效
就算原本的hashCode()取得很好，每个key的hashCode()不同，但是由于HashMap的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有hashCode()的低位参加运算，发生不同的hash值，但是得到的index相同的情况的几率会大大增加，这种情况称之为hash碰撞

扰动函数就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）
扩容时，如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。
因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量
如果追加节点后，链表数量》=8，则转化为红黑树

JAVA字符串格式化-String.format()的使用 ：http://blog.csdn.net/lonely_fireworks/article/details/7962171/

Fragment源码详解：http://www.cnblogs.com/punkisnotdead/p/4974527.html
Fragment可以加到其他ViewGrop中  ViewGroup就是我们在把这个Fragment添加进Activity时候写的id相对应的布局

LRU是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。采用LRU算法的缓存有两种：LrhCache和DisLruCache，分别用于实现内存缓存和硬盘缓存
LruCache的核心思想 就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队尾，即将被淘汰
LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序，其中accessOrder设置为true则为访问顺序，为false，则为插入顺序
int maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);
int cacheSize = maxMemory/8;
mMemoryCache = new LruCache<String,Bitmap>(cacheSize){
    @Override
    protected int sizeOf(String key, Bitmap value) {
        return value.getRowBytes()*value.getHeight()/1024;
    }
};

newCachedThreadPool：
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>());
newFixedThreadPool：
return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);
}
maximumPoolSize就是线程池的最大线程数；对于cached ThreadPool来说，这个值是Integer.MAX_VALUE，基本相当于无穷大了，什么样的机器能跑几十亿线程！！对于fixed ThreadPool来讲，这个值就是用户设定的线程池的数目。
keepAliveTime和unit决定了线程的缓存过期时间；对于cached ThreadPool来讲，线程的缓存过期时间是一分钟，换言之，一个工作线程如果一分钟都无事可干，就把它撤销掉以节省资源。fixed ThreadPool传入的时间是0，这里的含义是fixed ThreadPool中的工作线程是永远不过期的。
corePoolSize是线程池的最小线程数；对于cached ThreadPool，这个值为0，因为在完全没有任务的情况下，cached ThreadPool的确会成为“光杆司令”。至于fixed ThreadPool，这个fixed已经表明corePoolSize是等于线程总数的

Object类的hashcode方法取决于JVM的实现，比较典型的一种实现是基于内存地址进行哈希运算，此外也有基于伪随机数的实现

在weak reference指向的对象被回收后, weak reference本身其实也就没有用了. java提供了一个ReferenceQueue来保存这些所指向的对象已经被回收的reference. 用法是在定义WeakReference的时候将一个ReferenceQueue的对象作为参数传入构造函数

CopyOnWriteArrayList 的读操作（比如 get()）也不会阻塞其他操作；写操作则是通过复制一份，对复制版本进行操作，不会影响原来的数据
JDK8 中的 CopyOnWriteArrayList 底层实现也是数组，不同之处在于使用 Lock 而不是 synchronized 进行同步
优点：
    可以在多线程环境下操作 List
    读的效率很高
缺点：
    读的可能不是最新值
    每次写需要创建个新数组，占用额外内存
    
最大子序列问题 一个数组中哪几个连续的数相加和最大
int i, max = -1, temp_sum = 0;
for (i = 0; i < a.length; i++) {
  temp_sum += a[i];
  if (temp_sum > max) max = temp_sum;
  else if (temp_sum < 0) temp_sum = 0;
}

对象适配器中，适配器与被适配者之间是关联关系；类适配器中，适配器与被适配者之间是继承（或实现）关系

String -> Date
java.text.SimpleDateFormat formatter = new SimpleDateFormat( "yyyy-MM-dd ");
String s= "2011-07-09 "; 
Date date =  formatter.parse(s);
Date->String
java.text.SimpleDateFormat formatter = new SimpleDateFormat( "yyyy-MM-dd ");
String date = formatter.format(new Date());//格式化数据
语法：
G 年代标志符 
y 年 
M 月 
d 日 
h 时 在上午或下午 (1~12) 
H 时 在一天中 (0~23) 
m 分 
s 秒 
S 毫秒 
E 星期 
D 一年中的第几天 
F 一月中第几个星期几 
w 一年中第几个星期 
W 一月中第几个星期 
a 上午 / 下午 标记符 
k 时 在一天中 (1~24) 
K 时 在上午或下午 (0~11) 
z 时区

判定两个Java 类是相同的：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的

引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。
扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它
 
魔数 : 每个Class文件的头4个字节称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来表示身份识别。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意的改动。Class文件的魔数有很浪漫的气息，值为0xCAFEBABE这也是java是咖啡图标和商标名的原因之一。

版本号 : 紧接着4个魔数字节后面存储的是Class文件的版本号：第5和6个字节是次版本号，第7和第8个字节是主版本号。

常量池 ： 接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。（Class类文件中的常量池在类未加载到内存中可以称为静态常量池） 。入口处用2个字节标识常量池常量数量。




============================================================
=====                     基础知识                     =====
============================================================
TCP三次握手：
第一次握手：主机A发送位码为syn＝1,随机产生seq number=0的数据包到服务器，主机B由SYN=1知道，A要求建立联机；
第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=0的包
第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

HTTPS握手：
1、客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。
2、服务器SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。
3、客户利用服务器传过来的信息验证服务器的合法性，包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。验证没有通过，通讯将断开。
4、用户端随机产生一个用于后面通讯的“对称密码”，然后用证书中的公钥对其加密，然后将加密后的“预主密码”传给服务器。
5、如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。
6、如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。
7、服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。
8、客户端向服务器端发出信息，指明后面的数据通讯将使用的主密码为对称密钥，同时通知服务器客户端的握手过程结束。
9、服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。
10、SSL 的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

TCP：“面向连接”就是在正式通信前必须要与对方建立起连接，一个TCP连接必须要经过三次“对话”才能建立起来
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

一、数字摘要算法：验证消息的完整性，消息摘要采用单向Hash函数将需要计算的内容"摘要"成固定长度的串，其结果总是不同的(相对的)
MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。
SHA的全称是Secure Hash Algorithm，即安全散列算法，是基于MD4算法的，现在已成为公认的最安全的散列算法之一，摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。

二、对称加密：数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。
DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。
3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形
AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。

三、非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。

Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。
Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
Token的目的是为了验证用户登录情况以及减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

Oauth的认证和授权过程：
1.用户使用第三方的客户端（如访问第三方的网站，或使用第三方的应用），想对存放在服务提供者的某些资源进行操作。
2.第三方网站或应用向服务提供方请求一个临时令牌（Request Token）。
3.服务提供方验证第三方的身份后，授予其一个临时令牌。
4.第三方获得临时令牌后，将用户引导至服务提供方的授权页面请求用户授权。在这个过程中将临时令牌和客户端的回调连接发送给服务提供者。
5.用户在服务提供者的授权页面上输入自己的用户名和密码，然后授权该客户端访问相应的资源。
6.授权成功后，服务提供方引导用户返回第三方网站的的网页。
7.客户端根据临时令牌从服务提供方那里获取访问令牌（Access Token）。
8.服务提供方根据临时令牌和用户的授权情况授予客户端访问令牌。
9.客户端使用获取的访问令牌访问存放在服务提供方上的相应的资源。

微信扫码登录核心过程应该是这样的：浏览器获得一个唯一的、临时的UUID，通过长连接等待客户端扫描带有此UUID的二维码后，从长连接中获得客户端上报给服务器的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。 在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护，类似的应用还有扫码支付、扫码加公众号等功能.

UUID由以下几部分的组合：
（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
（2）时钟序列。
（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。

编码简史
1960年，美国人依照自己的语言，发明了ASCII，全称American Standard Code for Information Interchange。这套只支持英语系字符的编码规范，使用1个字节的前7位映射128个字符，其中33个控制字符和95个可显示字符（其中包括大小写字母各26个，10个阿拉伯数字，以及其他标点符号）

ISO/IEC 8859 字符集：这是拉丁语系国家推出了字符集，和ASCII码一样，也是单字节字符集，其特点是扩充了ASCII空置最高位，也就是128-255的范围，加入了其他字符

GB2312、GBK、GB18030字符集：这是针对简体中文推出的三个字符集，它们都是双字节的字符集，而且都向下兼容ASCII。依次按照GB2312、GBK、GB18030的顺序发展，排前面的是排后面的子集，而我们最常使用的是GBK，它包含的中文字符已经足够我们日常使用，所以平时见到GBK比见到GB18030多

其他的字符集：比如日本有JIS，台湾有繁体中文编码规范BIG5

字符集的概念是：收集一系列字符，然后规定每个字符映射到某个整数上。而编码方式，就规定这些映射字符的整数，应该如何在计算机中以二进制的形式存储或传输。
Unicode只是字符集，它的官方规范定义了三种编码方式：UTF-8，UTF-16，UTF-32

Unicode规范规定，使用U+前缀加上一个十六进制整数表示一个字符，比如U+0041表示大写拉丁字母A。而整个Unicode的字符集，需要U+000000到U+10FFFF的存储空间，一共使用了21个bit，共有1,112,064个位置

UTF-8的编码规则可以概括为二条：
单字节的字符，字节的第一位设为0，后面7位为这个符号的Unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
对于n字节(n = 2,3,4)的字符，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

视频的缓存播放目前有两种方案，
1、先下载视频到本地文件，然后把本地视频文件地址传给播放器，播放器实际播放的是本地文件。当播放器的播放进度大于当前的可播放的下载缓存进度，则暂停播放，等缓存到足够播放时间之后，再让播放器开始播放。这种方案的下载方式是与播放器完全没有关系的，只是顺序的将服务器下发的视频数据写入本地文件，然后让播放器来读取数据
   当缓存到500kb才把缓存的地址传给播放器，视频文件小于500kb则下载完之后再播放，起播慢（需要改进）。当下载进度比播放进度多5秒的数据量才让播放器播放，不然的话就暂停。如果seek到没有缓存的地方就切换到网络上停止当前的下载，浪费一些流量。每次下载都会保存一份配置文件，来保存是否下载完成，没下载完成则第二次根据当前缓存文件大小，重新开始顺序下载
2、使用本地代理服务器进行文件缓存，并将视频url地址转换成本地代理服务器地址来实现视频的缓存播放。

mp4文件其实有两种格式的数据，一种是头信息（即moov）在视频头部，一种是在视频尾部，之前已经提到过，视频播放器只有解析到了头部才可以播放视频，所以应先获得mp4的moov才能播放。因此对于moov信息在后面的mp4文件，必须在视频缓存的时候把它写到文件前面才可以正常播放

身份证号码验证
1、号码的结构 公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码， 八位数字出生日期码，三位数字顺序码和一位数字校验码。
2、地址码(前六位数） 表示编码对象常住户口所在县(市、旗、区)的行政区划代码，按GB/T2260的规定执行。
3、出生日期码（第七位至十四位） 表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。
4、顺序码（第十五位至十七位） 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号， 顺序码的奇数分配给男性，偶数分配给女性。
5、校验码（第十八位数）
（1）十七位数字本体码加权求和公式 S = Sum(Ai * Wi), i = 0, ... , 16 ，先对前17位数字的权求和 Ai:表示第i位置上的身份证号码数字值 Wi:表示第i位置上的加权因子 Wi: 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2
（2）计算模 Y = mod(S, 11)
（3）通过模得到对应的校验码 Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2


线性 O(n)：
int i;
for (i = 0; i < n; i++) {
}

对数阶 O(logn)
int count = 1;
while (count < n) {
    count = count * 2;
}

平方阶O(n2)
int i, j;
for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
    }
}
平方阶O(n*m)
int i, j， m;
for (i = 0; i < m; i++) {
    for (j = 0; j < n; j++) {
    }
}
平方阶O(n2)
int i, j;
for (i = 0; i < n; i++) {
    for (j = i; j < n; j++) {   // 注意 j = i 而不是 0
    }
}


O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)

============================================================
=====               Android基础知识                    =====
============================================================

在Android2.3时代，Bitmap的引用是放在堆中的，而Bitmap的数据部分是放在栈中的，需要用户调用recycle方法手动进行内存回收，而在Android2.3之后，整个Bitmap，包括数据和引用，都放在了堆中，这样，整个Bitmap的回收就全部交给GC了，这个recycle方法就再也不需要使用了。
（当旋转角度正常的时候，确实也是这样，但当旋转角度比较奇葩的时候，这两个bitmap对象居然变成了同一个）

ActivityManagerService组织回退栈时以ActivityRecord为基本单位，所有的ActivityRecord放在同一个ArrayList里，可以将mHistory看作一个栈对象，索引0所指的对象位于栈底，索引mHistory.size()-1所指的对象位于栈顶

android启动进程：
Zygote进程孵化出新的应用进程后，会执行ActivityThread类的main方法.在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到ActivityManagerService，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。
ActivityThread的main方法执行后,应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法

多进程的优势：
1、提高各个进程的稳定性，单一进程崩溃后不影响整个程序。
2、对于内存的时候更可控，可以通过手工释放进程，达到内存优化目的。
3、基于独立的JVM，各个模块可以充分解耦。
4、只保留daemon进程的情况下，会使应用存活时间更长，不容易被回收掉。

空进程存活时长： MAX_EMPTY_TIME = 30min
(缓存+空)进程个数上限：MAX_CACHED_APPS = SystemProperties.getInt(“sys.fw.bg_apps_limit”,32) = 32(默认)；
空进程个数上限：MAX_EMPTY_APPS = computeEmptyProcessLimit(MAX_CACHED_APPS) = MAX_CACHED_APPS/2 = 16；
trim空进程个数上限：TRIM_EMPTY_APPS = computeTrimEmptyApps() = MAX_EMPTY_APPS/2 = 8；
trim缓存进程个数上限：TRIM_CACHED_APPS = computeTrimCachedApps() = MAX_CACHED_APPS-MAX_EMPTY_APPS)/3 = 5;
TRIM_CRITICAL_THRESHOLD = 3;

adj:adj<5的应用不会被杀掉
前台进程0  可感知进程（前台service）2  服务进程（后台service）5  上一个app进程（返回键）7  测试（0 2 7home 9back）
前台进程：
拥有用户正在交互的 Activity（已调用onResume()）
拥有某个 Service，后者绑定到用户正在交互的 Activity
拥有正在“前台”运行的 Service（服务已调用 startForeground()）
拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
拥有正执行其 onReceive() 方法的 BroadcastReceiver

可视进程：
拥有不在前台、但仍对用户可见的 Activity（已调用onPause()）。
拥有绑定到可见（或前台）Activity 的 Service

服务进程：正在运行startService()方法启动的服务，且不属于上述两个更高类别进程的进程。

后台进程：对用户不可见的Activity的进程（已调用Activity的onStop()方法）

空进程：不含任何活动应用组件的进程

按HOME键，看起来似乎是退出了，但是其实这个软件并没有被关闭，而是转为了后台程序
按退出键，看起来也是退出没错，但这个软件其实是被转为了空置程序

1、进程名以":"开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以":"开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。
2、Android系统会为每个应用分配一个唯一的UID,具有相同UID的应用才能共享数据，两个应用通过ShareUID跑在同一个进程中，需要这两个应用有相同的ShareUID并且签名相同。它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。

Dalvik
1、允许有限内存中同时运行多个虚拟机实例，并且每一个Dalvik作为独立进程——防止虚拟机崩溃时，所有程序都被关闭
2、应用每次运行的时候，字节码都需要通过即时编译器转换为机器码
Dalvik监视所有的程序，并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。第一次加载后会生成Cache文件，以提供下次快速加载。
Dalvik解释其采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对接。这样可以节省一个指令后进行查表的时间。

Parcelable
describeContents方法：通常返回0，效值是CONTENTS_FILE_DESCRIPTOR(0x01)，指明这个Parcel的内容包含文件描述符，文件描述符就是操作文件的数据结构，获取到文件描述符可以完成所有文件相关的操作
parcel即缓冲区最大1MB，并且这是该进程中所有正在进行中的传输对象所公用的。
parcel传输大小大概是serializable的20倍了。但是官方建议使用Parcel，原因是说速度是serializable的将近10倍

Binder
客户端和服务端在同一进程，返回服务端的Stub本身，否则是Stub.proxy对象
最大线程数：15个
死亡代理：linkToDeath，当Binder死亡时，会收到通知
调用服务端/客户端的方法在当前线程中，然后挂起线程，收到返回数据唤醒
被调用的方法在Binder线程池中

Message
obj：只支持非空的系统实现Parcelable接口数据

文件共享
sharePreferences本身是文件共享，有一定缓存策略，内存中会保存一份缓存，在多进程模式下不可靠

ART 2014androidL
1、应用第一次安装的时候，字节码就预先编译成机器码
2、机器码占用存储空间更大，
3、安装时间变长
Dalvik	执行时编译	安装快	开启慢	占用空间小
ART	安装时编译	安装慢	开启快	占用空间大

省电开发
service的省电开发
1、查看service是否存活以及降低优先级
2、用IntentService代替Service开发
3、后台执行的定时任务Alarm机制，AndroidL后可以用JobScheduler代替
注意：从Android 4.4之后，Alarm任务的触发时间将会变得不准确
JobScheduler作为一个调度应用程序，负责当应用程序被唤醒时，提供适当的运行环境
网络方面，wifi更省电

Android沙箱：
Android 沙箱实现了应用程序的相互隔离，用于对文件系统的实体访问进行控制，也可以对其他Android系统资源进行访问控制。
沙箱系统的原理主要基于Linux系统的UID/GID机制
在 Linux 中，一个用户 ID 识别一个给定用户;在 Android 上，一个用户 ID 识别一个应用程序
应用程序在安装时被分配用户 ID，应用程序在设备上的存续期间内，用户 ID 保持不变。权限是关于允许或限制应用程序(而不是用户)访问设备资源

android5.0特性
1、Material Design
2、动态替换Theme：在setContentView之前调用setTheme方法；设置了Theme，需要finish当前Activity，然后重启当前Activity，让Theme生效
3、View的高度：elevation用于阴影，translationZ用于属性动画，汇总顺序改为先绘制高度小的，然后再按添加顺序绘制
注意：View的颜色背景为透明，则不会显示出阴影效果；只有子View的大小比父View小时，阴影才能显示出来
4、View的轮廓与剪裁（在Android5.1以上）
outlineProvider：默认是background
none：即使设置了evaluation也不显示阴影
background：按背景来显示轮廓，如果background是颜色值，则轮廓就是view的大小，如果是shape，则按shape指定的形状作为轮廓
bounds: View的矩形大小作轮廓
paddedBounds: View的矩形大小减去padding的值后的大小作轮廓。
注意：如果background是图片，那只能通过代码setOutlineProvider()来指定轮廓
View的裁剪是指将View按照轮廓裁剪，能改变View的形状，先设置轮廓，再设置根据轮廓裁剪View，目前只支持矩形，圆形，圆角矩形的裁剪
5、Palette的使用：从一张图片中拾取颜色
6、水波纹动画，自定义水波纹动画以及状态选择器动画
水波纹动画：在Android5.0以上默认自带
自定义水波纹动画：使用ViewAnimationUtils创建圆形水波纹动画，使用ripple标签或者RippleDrawable可以更改控件水波纹动画颜色
状态选择器动画：通过stateListAnimator属性指定状态选择器的动画
7、CardView的使用：CardLayout拥有高度和阴影，以及轮廓裁剪，圆角等功能
8、RecyclerView的使用
9、ToolBar的使用：用来代替ActionBar，但是比ActionBar更加灵活
10、Android 5.0新特性的向下兼容，通过Support Library使用，使用新API的布局放在res/layout-v21 res/drawable-v21 res/values-v21中

Android 6.0新控件
1、TextInputLayout的使用
2、FloatingActionButton的使用
3、Snackbar的使用
4、TabLayout的使用
5、CoordinatorLayout的使用

Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity).我们需要在16ms内完成下一次要刷新的界面的相关运算
新绘制缓存
1、将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。
2、如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。
3、Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。
第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。

增量更新
增量更新的流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的）
1、用户手机上提取当前安装应用的apk；2、如何利用old.apk和new.apk生成增量文件；3、增加文件与1.中的old.apk合并，然后安装

Window
Window是以View的形式存在，对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。无法直接访问Window，对Window的访问必须通过WindowManager。
Window有三种类型，分别是应用Window、子Window和系统Window。
应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。
系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。
在三类Window中，应用Window的层级范围是1~99，子Window的层级范围是1000~1999，系统Window的层级范围是2000~2999，这些层级属性范围对应着WindowManager.LayoutParams的type参数。
如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：mLayoutParams.type = LayoutParams.TYPE_SYSTEM_ERROR

WindowManagerGlobal的addView方法分为如下几步：
1、检查参数是否合法，如果是子Window那么还需要调整一些布局参数
2、创建ViewRootImpl并将View添加到列表中
3、通过ViewRootImpl来更新界面并完成Window的添加过程

dispatchDetachedFromWindow方法主要做四件事：
1、垃圾回收的工作，比如清除数据和消息，移除回调。
2、通过Session的remove方法删除Window，mWindowSession.remove(mWindow)，这同样是一个IPC过程，最终会调用WindowManagerService的removeWindow方法
3、调用View的dispatchDetachedFromWindow方法，在内部调用View的onDetachedFromWindow()以及onDetachedFromWindowInternal()。
4、调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews，需要将当前Window所关联的这三类对象从列表中删除。

Activity的Window创建过程
1、由ActivityThread中的performLaunchActivity()来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用其attach方法为其关联运行过程中所依赖的一系列上下文环境变量。
2、Activity实现了Window的Callback接口，当Window接收到外界的状态变化时就会调用Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等。
3、Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的。 PhoneWindow方法大致遵循如下几个步骤：
    如果没有DecorView，那么就创建它
    将View添加到DecorView的mContentParent中
    回调Activity的onCreateChanged方法通知Activity视图已经发生改变

Dialog的Window创建过程，有如下步骤：
1、创建Window:Diolog中Window的创建同样是通过PolicyManager的makeNewWindow方法来完成的，创建后的对象实际上就是PhoneWindow。
2、初始化DecorView并将Dialog的视图添加到DecorView中
3、将DecorView添加到Window中并显示：普通的Dialog有一个特殊之处，就是必须采用Activity的Context，如果采用Application的Context，那么就会报错。（应用token只有Activity拥有，所以这里只需要Activity作为Context来显示对话框即可）。
service：必须在 Manifest 里面注册系统权限（<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />），在显示 dialog 的时候必须要加一个 flag（WindowManager.LayoutParams.TYPE_SYSTEM_ALERT）

Toast的Window创建过程
1、在Toast的内部有两类IPC过程，第一类是Toast访问NotificationManagerService，第二类是NotificationManagerService回调Toast里的TN接口。
2、Toast属于系统Window，它内部的视图由两种方式指定：一种是系统默认的演示，另一种是通过setView方法来指定一个自定义的View
3、Toast具有定时取消功能，所以系统采用了Handler。Toast的显示和隐藏是IPC过程，都需要NotificationManagerService（NMS）来实现，在Toast和NMS进行IPC过程时，NMS会跨进程回调Toast中的TN类中的方法，TN类是一个Binder类，运行在Binder线程池中，所以需要通过Handler将其切换到当前发送Toast请求所在的线程，所以Toast无法在没有Looper的线程中弹出。
4、对于非系统应用来说，mToastQueue最多能同时存在50个ToastRecord，这样做是为了防止DOS(Denial of Service，拒绝服务)。因为如果某个应用弹出太多的Toast会导致其他应用没有机会弹出Toast。
非UI线程中显示Toast：
Looper.prepare();
Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_SHORT).show();
Looper.loop();

布局
LinearLayout 在 measure 的时候，在横向或者纵向会去测量子 View 的宽度或高度，且只会测量一次，但是当设置 layout_weight 属性的时候会去测量两次才能获得精确的展示尺寸
RelativeLayout 在 measure 的时候会在横向和纵向各测量一次
如果带有 weight 属性的 LinearLayout 或者 RelativeLayout 被套嵌使用，measure 所费时间可能会呈指数级增长（两个套嵌的叶子 view 会有四次 measure，三个套嵌的叶子 view 会有8次的 measure）。为了缩短这个时间，保持树形结构尽量扁平（深度低），而且尽量要移除所有不需要渲染的 view

布局优化
避免复杂的 View 层级
避免 layout 顶层使用 RelativeLayout
布局层次相同的情况下，使用 LinearLayout
复杂布局建议采用 RelativeLayout 而不是多层次的 LinearLayout
<include/> 标签复用
<merge/> 标签减少嵌套
尽量避免 layout_weight
视图按需加载或者使用 ViewStub

去除重复或者不必要的 background
点击态中的 normal 尽量设置成 transparent
去除 window 中的 background（这个可以通过处理 decorView 或者设置 Theme 的方式）
若是自定义控件的话，通过 canvas.clipRect() 帮助系统识别那些可见的区域


DOM,SAX,PULL三种解析方式:
DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机
SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。
PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。

标记回收算法（Mark and Sweep GC）：从”GC Roots”集合开始，将内存整个遍历一次，保留所有可以被GC Roots直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收，这个算法需要中断进程内其它组件的执行并且可能产生内存碎片

复制算法 (Copying）：将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

标记-压缩算法 (Mark-Compact)：先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

分代：将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。对于新生代适用于复制算法，而对于老年代则采取标记-压缩算法。

复制和标记-压缩算法的区别：
前者是用空间换时间后者则是用时间换空间
前者的在工作的时候是不没有独立的“Mark”与“Copy”阶段的，而是合在一起做一个动作，就叫Scavenge（或Evacuate，或者就叫Copy）。也就是说，每发现一个这次收集中尚未访问过的活对象就直接Copy到新地方，同时设置Forwarding Pointer，这样的工作方式就需要多一份空间。
后者在工作的时候则需要分别的Mark与Compact阶段，Mark阶段用来发现并标记所有活的对象，然后compact阶段才移动对象来达到Compact的目的。如果Compact方式是Sliding Compaction，则在Mark之后就可以按顺序一个个对象“滑动”到空间的某一侧。因为已经先遍历了整个空间里的对象图，知道所有的活对象了，所以移动的时候就可以在同一个空间内而不需要多一份空间。
所以新生代的回收会更快一点，老年代的回收则会需要更长时间，同时压缩阶段是会暂停应用的，所以给我们应该尽量避免对象出现在老年代。

GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。
GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。
GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。
GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。

Alloc内存不够的时候会采用非并发GC，而在Alloc后发现内存达到一定阀值的时候又会触发并发GC

ART运行时内部使用的Java堆的主要组成包括Image Space、Zygote Space、Allocation Space和Large Object Space四个Space，Image Space用来存在一些预加载的类， Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的，Large Object Space就是一些离散地址的集合，用来分配一些大对象从而提高了GC的管理效率和整体性能

kGcCauseForAlloc: 当要分配内存的时候发现内存不够的情况下引起的GC，这种情况下的GC会Stop World.
kGcCauseBackground: 当内存达到一定的阀值的时候会去出发GC，这个时候是一个后台GC，不会引起Stop World.
kGcCauseExplicit，显示调用的时候进行的gc，如果ART打开了这个选项的情况下，在system.gc的时候会进行GC.

Cow策略：一开始的时候（未复制Zygote进程的地址空间的时候），应用程序进程和Zygote进程共享了同一个用来分配对象的堆。当Zygote进程或者应用程序进程对该堆进行写操作时，内核就会执行真正的拷贝操作，使得Zygote进程和应用程序进程分别拥有自己的一份拷贝，这就是所谓的Cow

Android GC 那点事:
https://juejin.im/post/5909c7ef570c3500583bf433
https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400021278&idx=1&sn=0e971807eb0e9dcc1a81853189a092f3&scene=0&key=b410d3164f5f798eafd870697d352ac86e0e54b9605b5fcd2c6a62268c16080ee291069627f13ed906cc2f39706b6a54&ascene=0&uin=NzY0MTg2ODU%3D&devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.10.5+build(14F27)&version=11000003&pass_ticket=nhSGhYD4LC9FWvUPv26Y7AdIzqEDu8FTImf2AKlyrCk%3D


ActivityManager.getMemoryClass()：     虚拟机java堆大小的上限，分配对象时突破这个大小就会OOM
ActivityManager.getLargeMemoryClass()：manifest中设置largeheap=true时虚拟机java堆的上限
Runtime.getRuntime().maxMemory() ：    当前虚拟机实例的内存使用上限，为上述两者之一
Runtime.getRuntime().totalMemory() ：  当前已经申请的内存，包括已经使用的和还没有使用的
Runtime.getRuntime().freeMemory() ：   上一条中已经申请但是尚未使用的那部分。那么已经申请并且正在使用的部分used=totalMemory() - freeMemory()
ActivityManager.MemoryInfo.totalMem:   设备总内存
ActivityManager.MemoryInfo.availMem:   设备当前可用内存
/proc/meminfo                                           记录设备的内存信息

OutOfMemoryError发生：堆操作时 创建线程时
进程每打开一个文件就会产生一个文件描述符fd（记录在/proc/pid/fd下面），这个限制表明fd的数目不能超过Max open files规定的数目。
触发大量网络连接（每个连接处于独立的线程中）并保持，每打开一个socket都会增加一个fd（/proc/pid/fd下多一项），也可以用其他方法，比如打开文件，创建handlerthread等等

这些限制中与线程相关的是/proc/sys/kernel/threads-max，规定了每个进程创建线程数目的上限
创建大量的空线程（不做任何事情，直接sleep）

可以导致OOM的原因有以下几种： 
文件描述符(fd)数目超限，即proc/pid/fd下文件数目突破/proc/pid/limits中的限制。可能的发生场景有：
短时间内大量请求导致socket的fd数激增，大量（重复）打开文件等
线程数超限，即proc/pid/status中记录的线程数（threads项）突破/proc/sys/kernel/threads-max中规定的最大线程数。可能的发生场景有：
app内多线程使用不合理，如多个不共享线程池的OKhttpclient等等
传统的java堆内存超限，即申请堆内存大小超过了 Runtime.getRuntime().maxMemory()

-dalvik.vm.heapstartsize            
堆分配的初始大小，调整这个值会影响到应用的流畅性和整体ram消耗。这个值越小，系统ram消耗越慢，但是由于初始值较小，一些较大的应用需要扩张这个堆，从而引发gc和堆调整的策略，会应用反应更慢。相反，这个值越大系统ram消耗越快，但是程序更流畅。

-dalvik.vm.heapgrowthlimit     
受控情况下的极限堆（仅仅针对dalvik堆，不包括native堆）大小，dvm heap是可增长的，但是正常情况下dvm heap的大小是不会超过dalvik.vm.heapgrowthlimit的值（非正常情况下面会详细说明）。这个值控制那些受控应用的极限堆大小，如果受控的应用dvm heap size超过该值，则将引发oom（out of memory）。

-dalvik.vm.heapsize 
不受控情况下的极限堆大小，这个就是堆的最大值。不管它是不是受控的。这个值会影响非受控应用的dalvik heap size。一旦dalvik heap size超过这个值，直接引发oom。

如果要使用大堆。需要在manifest中指定android:largeHeap为true。这样dvm heap最大可达dalvik.vm.heapsize。
1  首先判断一下需要申请的size是不是过大，如果申请的size超过了堆的最大限制，则转入步骤6
2  尝试分配，如果成功则返回，失败则转入步骤3
3  判断是否gc正在进行垃圾回收，如果正在进行则等待回收完成之后，尝试分配。如果成功则返回，失败则转入步骤4
4  自己启动gc进行垃圾回收，这里gcForMalloc的参数是false。所以不会回收软引用，回收完成后尝试分配，如果成功则返回，失败则转入步骤5
5  调用dvmHeapSourceAllocAndGrow尝试分配，这个函数会扩张堆。所以heap startup的时候可以给一个比较小的初始堆，实在不够用再调用它进行扩张
6  进入回收软引用阶段，这里gcForMalloc的参数是ture，所以需要回收软引用。然后调用dvmHeapSourceAllocAndGrow尝试分配，如果失败则抛出OOM 

这里会把HeapSource的growthLimit设置为maximumSize，说简单点就是把growthLimit有原来dalvik.vm.heapgrowthlimit的值调整为dalvik.vm.heapsize。不过分配的时候判断oom的依据是根据heap中的maximumSize来决定。这里不得不说一下HeapSource的两个堆了，heaps[]数组中有两个堆。简单来讲，0号堆是可用堆，是开发给上层使用的。1号堆是fork的时候从zygote进程直接复制过来的，这个是死的，不会由dvm开放给上层使用。overhead标明了堆中已经分配可多少（包括0号堆和1号堆）。所以上层能分配打的最大使用量为 gHs->maxmumSize - overhead。


热修复--腾讯：
1、根据Android虚拟机的类加载机制，同一个类只会被加载一次。
2、Android系统通过PathClassLoader来加载系统类和主dex中的类。而DexClassLoader则用于加载其他dex文件中的类。上述两个类都是继承自BaseDexClassLoader，具体的加载方法是findClass
3、加载补丁的思路如下：
    在Application的onCreate()方法中获取应用本身的BaseDexClassLoader,然后通过反射得到对应的dexElements
    创建一个新的DexClassLoader实例，然后加载sdCard上的补丁包，然后通过同样的方法得到对应的dexElements
    将两个dexElements合并，然后再利用反射将合并后的dexElements赋值给应用本身的BaseDexClassLoader
4、
    在apk安装的时候系统会将dex文件优化成odex文件，在优化的过程中会涉及一个预校验的过程
    如果一个类的static方法，private方法，override方法以及构造函数中引用了其他类，而且这些类都属于同一个dex文件，此时该类就会被打上CLASS_ISPREVERIFIED
    如果在运行时被打上CLASS_ISPREVERIFIED的类引用了其他dex的类，就会报错
    所以MainActivity的onCreate()方法中引用另一个dex的类就会出现上文中的问题
    正常的分包方案会保证相关类被打入同一个dex文件
    想要使得patch可以被正常加载，就必须保证类不会被打上CLASS_ISPREVERIFIED标记。而要实现这个目的就必须要在分完包后的class中植入对其他dex文件中类的引用
    要在已经编译完成后的类中植入对其他类的引用，就需要操作字节码，惯用的方案是插桩。常见的工具有javaassist，asm等。

目前Android共支持七种不同类型的CPU架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)
    armeabi设备只兼容armeabi；
    armeabi-v7a设备兼容armeabi-v7a、armeabi；
    arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi；
    X86设备兼容X86、armeabi； （x86设备上模拟arm的虚拟层）
    X86_64设备兼容X86_64、X86、armeabi； （x86设备上模拟arm的虚拟层）
    mips64设备兼容mips64、mips；
    mips只兼容mips；
    
taskAffinity表示当前activity具有亲和力的一个任务大致可以这样理解，这个 taskAffinity表示一个任务，这个任务就是当前activity所在的任务。具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。    
这个属性决定两件事：当activity被re-parent时，它可以被re-paren哪个任务中；当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。
默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的 应用中的activity的taskAffinity设置成相同的值。
为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task
任务（Task）不仅可以跨应用（Application），还可以跨进程（Process） 即 运行在同一个任务栈中，运行在不同的进程中
在启动一个singleTask的Activity实例时，如果系统中已经存在这样一个实例，就会将这个实例调度到任务栈的栈顶，并清除它当前所在任务中位于它上面的所有的activity

如果需要将同一个APP的不同Activity在Recent中显示，需满足如下两点：
1、LaunchMode设置为singleInstance
2、设置android:taskAffinity参数

Intent.FLAG_ACTIVITY_SINGLE_TOP
该标志位表示使用singleTop模式来启动一个Activity，与在清单文件指定android:launchMode=”singleTop”效果相同。
Intent.FLAG_ACTIVITY_CLEAR_TOP
该标志位表示使用singleTask模式来启动一个Activity，与在清单文件指定android：launchMode=”singleTask”效果相同。
Intent.FLAG_ACTIVITY_NO_HISTORY
使用该模式来启动Activity，当该Activity启动其他Activity后，该Activity就被销毁了，不会保留在任务栈中。如A-B,B中以这种模式启动C，C再启动D，则任务栈只有ABD。
Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
使用该标识位启动的Activity不添加到最近应用列表，也即我们从最近应用里面查看不到我们启动的这个activity。与属性android:excludeFromRecents=”true”效果相同。
Intent.FLAG_ACTIVITY_NEW_TASK
该标志位表示使用一个新的Task来启动一个Activity，相当于在清单文件中给Activity指定“singleTask”启动模式。通常我们在Service启动Activity时，由于Service中并没有Activity任务栈，所以必须使用该Flag来创建一个新的Task。

Android进程保活招式大全   http://dev.qq.com/topic/57ac4a0ea374c75371c08ce8
查看当前进程：adb root(如果需要的话) adb shell  ps   cat /proc/{pid}/oom_adj

LeakCanary原理
当开发者想要检测一个变量是否存在内存泄漏时,直接通过RefWatcher的watch方法来进行监控,然后RefWatcher会为要监控的对象创建一个WeakReference,以及生成一个UUID来作为key表示指定变量,之后会在主线程空闲时在非主线程中判断变量是否存在泄露. 首先移除已经被回收的变量,紧接着判断监控的变量是否在为已经被移除,如果已经移除立即返回,如果没有移除,执行GC然后在判断一次变量是否被回收,如果没有回收,则立即执行dump heap,然后分析heap的使用情况来得到内存泄漏的引用链.
IdleHandler的原理就是在messageQueue因为空闲等待消息时给使用者一个hook。那AndroidWatchExecutor会在主线程空闲的时候，派发一个后台任务，这个后台任务会在DELAY_MILLIS时间之后执行。LeakCanary设置的是5秒。
在reference类加载的时候，java虚拟机会创建一个最大优先级的后台线程，这个线程的工作原理就是不断检测pending是否为null，如果不为null，就将其放入ReferenceQueue中，pending不为null的情况就是，引用所指向的对象已被GC，变为不可达。
那么只要我们在构造弱引用的时候指定了ReferenceQueue，每当弱引用所指向的对象被内存回收的时候，我们就可以在queue中找到这个引用。如果我们期望一个对象被回收，那如果在接下来的预期时间之后，我们发现它依然没有出现在ReferenceQueue中，那就可以判定它的内存泄露了
LeakCanary只支持4.0以上，原因是其中在watch 每个Activity时适用了Application的registerActivityLifecycleCallback函数，这个函数只在4.0上才支持，但是在4.0以下也是可以用的，可以在Application中将返回的RefWatcher存下来，然后在基类Activity的onDestroy函数中调用

判断Application是否是在service进程里面启动，最直接的方法就是判断当前进程名和service所属的进程是否相同。当前进程名的获取方式是使用ActivityManager的getRunningAppProcessInfo方法，找到进程pid与当前进程pid相同的进程，然后从中拿到processName. service所属进程名。获取service应处进程的方法是用PackageManager的getPackageInfo方法。

apk签名：
a. 解析出 CERT.RSA 文件中的证书、公钥，解密 CERT.RSA 中的加密数据
b. 解密结果和 CERT.SF 的指纹进行对比，保证 CERT.SF 没有被篡改
c. 而 CERT.SF 中的内容再和 MANIFEST.MF 指纹对比，保证 MANIFEST.MF 文件没有被篡改
d. MANIFEST.MF 中的内容和 APK 所有文件指纹逐一对比，保证 APK 没有被篡改

Realm 的性能应该是最好的，同时它执行跨平台，且并不是采用 SQLite 的持久化引擎。但是也有不少的缺点（具体查看文章为什么我不再使用Realm）。
greenDAO 是基于AndroidSQLite的最快、性能最强悍的数据库框架，因为他不涉及反射，靠的是代码辅助生成。

当我们用Application去启动standard模式的activity时会报错，这是因为非activity类型的context没有所谓的任务栈，解决这个问题方法是为待启动的activity指定FLAG_ACTIVITY_NEW_TASK 标记位，这样在启动的时候为该activity创建了一个新的任务栈，这个时候待启动的activity实际上是以singleTask 模式启动的

ListView RecyclerView
Recycler
（1）检查mChangedScrap，若匹配到则返回相应holder
（2）检查mAttachedScrap，若匹配到且holder有效则返回相应holder
（3）检查mViewCacheExtension，若匹配到则返回相应holder
（4）检查mRecyclerPool，若匹配到则返回相应holder
（5）否则执行Adapter.createViewHolder()，新建holder实例
（6）返回holder再通过 holder.itemView 得到了要添加的 View.

在 Recycler的各级缓存中，只有RecycledViewPool是按照 viewType 去存储和获取缓存的 ViewHolder 来达到复用，其它缓存需要匹配 layoutPosition 或 getItemId再加上 viewType 。
缓存级别最高的是mChangedScrap它是预处理layout时添加的，对应方法 dispatchLayoutStep1；mAttachedScrap是其次，它是attach到容器未移除的缓存复用很适用频繁抖动滑动；mCachedViews再次，它是 detach 的 ViewHolder 缓存，mViewCacheExtension是用户扩展的缓存池一般用户是没有实现的，最后才是 RecyclerViewPool它只需要按viewType 返回

draw 过程比较简单，只是简单循环调用了ItemDecoration去绘制背景和前景视图

Resource Merge
build variant > build type > product flavor > main source set > library dependencies

Resource Overlay：对资源一种额外补充，当在主资源集中未找到该资源时，这时会在我们添加的重叠包中进行查找
additionalParameters '-S', 'src/main/res2',
            '-S', 'src/main/res3',
            '--auto-add-overlay'

Instant Apps 是基于 Android 操作系统的，微信小程序是基于微信 App 生态的，但本质上还是不一样的，Instant Apps 本质上还是原生 App，只不过允许你在下载安装之前，先体验下 App 部分模块的功能，觉得不错，适合你，那么你可以再下载安装，而微信小程序本质上不是原生应用，他是基于一种类似 React Native 的框架来达到原生的体验，而且只能在微信内部运行

项目编译时产生的R文件存在的位置是与Manifest 中配置包名也就是项目的工程目录相对应的目录中，而代码中获取的项目包名是 build.gradle 中配置的applicationId对应的包名，如果再使用这个包名去反射获取R文件当然是失败的了

Android 使用的Java 库是Apache的Harmony, 与官方Java库接口相同，里面实现不一样。
就在06年的时候Sun公司宣布会将JDK开源，但是直到2009年4月才正式发布，而Android已经在2008年发布第一步部智能手机了。所以Google最早的时候使用了当时Apache的Java开源实现Harmony项目。
可惜Sun公司一直不承认Harmony，前不久Harmony那一帮人怒了，给Oracle放狠话说再不承认我我就抵制Java7，结果反倒把Google吓坏了，于是就出现了google宣布切换到openjdk上这条新闻。在Android N上，已经切换到OpenJDK了；基本可以认为Android SDK下的源码与JDK相同。

Bitmap图片加载大小：
理论上是：getByteCount(){return getRowBytes() * getHeight(); } 即：bitmapInRam = bitmapWidth * 4 bytes * bitmapHeight
实际上还与其设备的density 有关
scale = targetDensity / inDensity  （设备的 density  /  bitmap 所在文件夹对应的 density）
bitmapInRam = (bitmapWidth*scale) * (bitmapHeight*scale) * 4 bytes

触发ANR后输出traces.txt的过程：
1、有序广播在注册后发送
2、AMS设置广播超时时间，通过Handler进行延迟设定
3、广播超时触发超时机制
4、Framework层发送信号给虚拟机
5、虚拟机dump出特定进程所有线程信息并存储到traces.txt文件中

DB:getWritableDatabase与getReadableDatabase：
两个方法都是返回读写数据库的对象，但是当磁盘已经满了时，getWritableDatabase会抛异常，而getReadableDatabase不会报错，它此时不会返回读写数据库的对象，而是仅仅返回一个读数据库的对象。
getReadableDatabase会在问题修复后继续返回一个读写的数据库对象。
两者都是数据库操作，可能存在延迟等待，所以尽量不要在主线程中调用。

证书使用场景
程序升级
当新版程序和旧版程序的数字证书和AppID相同时，Android系统才会认为这两个程序是同一个程序的不同版本。如果新版程序和旧版程序的数字证书不相同，但AppID一样，Android系统认为他们是不同的程序，并产生冲突，会要求新程序更改AppID。

程序插件化设计和开发
插件化开发时，需要确保各插件的数字证书是相同的。Android系统允许拥有同一个数字签名的程序运行在一个进程中，Android程序会将他们视为同一个程序。所以开发者可以将自己的程序分模块开发，而用户只需要在需要的时候下载适当的模块。

通过权限(permission)的方式在多个程序间共享数据和代码
Android提供了基于数字证书的权限赋予机制，应用程序可以和其他的程序共享功能或者数据给那些与自己拥有相同数字证书的程序。如果某个权限(permission)的protectionLevel是signature，则这个权限就只能授予那些跟该权限所在的包拥有同一个数字证书的程序。

Android证书相关要点
数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。程序有效期内被安装后，即使证书过期也不会影响程序的正常功能了。
如果计划将应用程序发布到Android Market, 为应用签名的key的有效期必须在2033年10月22日以后，Market服务器强制执行这个规则。
debug.keystore在不同的机器上所生成的可能都不一样，即如果不同开发机器上生成的相同App有可能不会覆盖安装。
大部分应用程序商店（包括谷歌Play商店）不会接受调试证书签名的APK。
证书中的有效期、证书持有者姓名、组织名称、城市及国家等信息不影响证书是否相同的判定，即只要证书公私钥信息一致，系统就判定证书相同。

Android字体
Android 系统默认使用的是一款叫做 Robote 的字体。Robote 本身就是 Google 自己的字体格式，Android 和 Chrome 操作系统上，默认都会使用 Robote 字体，并且也是 Google 视觉语言推荐的字体
Android 本身已经提供了一些修改字体样式的属性和方法 
android:textStyle：对所有的字体都生效，可选项有 normal|bold|italic
android:typeface：它可选的属性有 normal|sans|serif|monospace 等。normal 和 sans 的字体其实是一样的，serif 是一个带衬线的字体，而 nonospace 是等宽字体
android:fontFamily：看着像是对 typeface 的一次加强，从它的可选项就能看出来，它更细致的区分了字体的样式 
如果同时配置了 typeface 和 fontFamily ，将使用 fontFamily 配置的字体，它们俩都是可以配合 typeStyle 属性一起使用的
通过 android:theme 来配置一个 App 的主题——@style/AppTheme 。在其中追加关于字体的属性 android:fontFamily

DexClassLoader: 从 .jar 和 .apk 文件加载包含 classes.dex 条目的类
PathClassLoader: 对本地文件系统中的文件和目录列表进行操作，但不尝试从网络加载类 
一个应用启动后，可以看到有两个 ClassLoader 的实例输出，一个PathClassLoader，应用启动时创建的，用于加载 apk 中的类，另一个是BootClassLoader，系统启动时创建的，用于加载系统相关的类。
任何运行的Android应用至少包含有两个 ClassLoader，每个应用中的PathClassLoader拥有同一个parent即是BootClassLoader，这样就保证了系统代码共享以及应用代码隔离 

如果我们需要上层覆盖VIEW不可被点击并且要将点击事件穿透下去，我们选用setClickable方法】
如果我们需要上层覆盖VIEW不可被点击并且不需要将点击事件穿透下去，我们选用setEnabled方法

当系统因为内存不足需要回收 Activity 占用的资源时，Activity 在执行完 onPause() 方法后就可能面临着被销毁的危险，有些生命周期方法，如：onStop()、onDestroy() 根本就不会执行

BroadcastReceiver 有生命周期，但比较短，而且很短。当它的 onReceive() 方法执行完成后，它的生命周期也就随之结束了。这时候由于 BroadcastReceiver 已经不处于 active 状态，所以极有可能被系统干掉。也就是说如果你在 onReceive() 去开线程进行异步操作或者打开 Dialog 都有可能在没达到你要的结果时进程就被系统杀掉了（超时时间10s）

我们要先了解 Android 的 ActivityManagerService 有一个专门的消息队列来接收发送出来的广播，sendBroadcast() 执行完后就立即返回，但这时发送来的广播只是被放入到队列，并不一定马上被处理。当处理到当前广播时，又会把这个广播分发给注册的广播接收分发器ReceiverDispatcher，ReceiverDispatcher 最后又把广播交给接 Receiver 所在的线程的消息队列去处理（就是你熟悉的 UI 线程的 Message Queue）。

整个过程从发送 ActivityManagerService 到 ReceiverDispatcher 进行了两次 Binder 进程间通信，最后还要交到 UI 的消息队列，如果基中有一个消息的处理阻塞了 UI，当然也会延迟你的 onReceive() 的执行

图片压缩：
质量压缩：bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)，转换为JPEG,PNG（100无用）,WEBP（比JPEG省30%）
采样压缩：放大图像称为上采样，缩小图像称为下采样。对应有四种常见方法：邻近采样（常用），双线性采样，双立方／双三次采样，Lanczos

PNG->JPEG，不会降低图片尺寸，但会降低视觉质量，从而降低存储体积。由于尺寸不变，但解码后，bitmap占用内存一样

Android Skia 图像引擎：
Skia 是一个 Google 自己维护的 c++ 实现的图像引擎，提供了基本的画图和简单的编解码功能，可以挂接其他的第三方编码解码库或者硬件编解码库，例如 libpng 和 libjpeg，libgif 等
最终 Android 编码保存图片的逻辑是 Java 层函数-->Native 函数-->Skia函数-->对应第三库函数（例如 libjpeg）
tip：
Android 在之前从某种程度来说使用的算是 libjpeg 的功能阉割版，图像数据编码默认使用的是 standard huffman，而不是 optimized huffman，也就是说使用的是默认的哈夫曼表，并没有根据实际图片去计算相对应的哈夫曼表，Google 在初期考虑到手机的性能瓶颈，计算图片权重这个阶段非常占用 CPU 资源的同时也非常耗时，因为此时需要计算图片所有像素 argb 的权重，这也是早期 Android 的图片压缩率不是特别高的原因之一

邻近采样：
BitmapFactory.Options options = new BitmapFactory.Options();
//或者 inDensity 搭配 inTargetDensity 使用，算法和 inSampleSize 一样
options.inSampleSize = 2;
Bitmap compress = BitmapFactory.decodeFile("/sdcard/test.png", options);
官方的解释中我们可以看到 x（x 为 2 的倍数）个像素最后对应一个像素，由于采样率设置为 1/2，所以是两个像素生成一个像素。邻近采样的方式比较粗暴，直接选择其中的一个像素作为生成像素，另一个像素直接抛弃

双线性采样
Bitmap bitmap = BitmapFactory.decodeFile("/sdcard/test.png");
Bitmap compress = Bitmap.createScaledBitmap(bitmap, bitmap.getWidth()/2, bitmap.getHeight()/2, true);（ 函数最终也是使用第二种方式的 matrix 进行缩放）
或
Bitmap bitmap = BitmapFactory.decodeFile("/sdcard/test.png");
Matrix matrix = new Matrix();
matrix.setScale(0.5f, 0.5f);
bm = Bitmap.createBitmap(bitmap, 0, 0, bit.getWidth(), bit.getHeight(), matrix, true);
参考了源像素相应位置周围 2x2 个点的值，根据相对位置取对应的权重，经过计算之后得到目标图像，具有抗锯齿功能

双立方／双三次采样 （ ffmpeg libswscale/swscale.c ）
更进一步参考了源像素某点周围 4x4 个像素,计算量最大，下采样与双线性差不多，上采样最佳

Lanczos
Lanczos 算法和双三次插值算法都是使用卷积核来通过输入像素计算输出像素，只不过在算法表现上稍有不同

SharedPreferences
基于单个xml文件实现的，并且，所有持久化数据都是一次性加载到内存，如果数据过大，是不合适采用SharedPreferences存放的
SharePreferences数据的加载是同步，读取xml配置，如果其他线程想要在读取之前就是用的话，就会被阻塞，一直wait等待，直到数据读取完成
再次访问的时候，其实访问的是内存缓存
提交事务的时候有两种方式，一种是apply，另一种commit，前者是异步的，后者是同步的
commit函数一般会在当前线程直接写文件，而apply则提交一个事务到已给线程池，之后直接返回
MODE_MULTI_PROCESS是Google提供的一个多进程模式，作用只会在getSharedPreferences的时候，才会重新从xml重加载

SharePreferences是Android基于xml实现的一种数据持久话手段
SharePreferences不支持多进程
SharePreferences的commit与apply一个是同步一个是异步（大部分场景下）
不要使用SharePreferences存储太大的数据

MultiDex初次启动APP优化：
安装完成并初次启动APP的时候，5.0以下某些低端机会出现ANR或者长时间卡顿不进入引导页，而罪魁祸首是MultiDex.install(Context context)的dexopt过程耗时过长
1、在Application.attachBaseContext(Context base)中，判断是否初次启动，以及系统版本是否小于5.0，如果是，跳到2；否则，直接执行MultiDex.install(Context context)。
2、开启一个新进程，在这个进程中执行MultiDex.install(Context context)。执行完毕，唤醒主进程，自身结束。主进程在开启新进程后，自身是挂起的，直到被唤醒。
3、唤醒的主进程继续执行初始化操作。

Android 搜狗输入法在微信中发送图片和表情：
把表情或图片的路径提交到编辑框，微信的编辑框自动就会帮你识别该图片

线程池实践：
AsynTask 4.0
默认线程池是 SingleThreadExecutor; 单一串行线程池。
内部还内置一个CPU*2+1的 FixedThreadPool，命名为：THREAD_POOL_EXECUTOR。

RxJava
Schedulers.io( )	 默认是一个CachedThreadScheduler，用于IO密集型任务，如异步阻塞IO操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。
Schedulers.computation( )	 默认是：FixedThreadPool。用于CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算，事件循环或和回调处理
Schedulers.immediate( )	在当前线程立即开始执行任务，相当于不指定线程。这是默认的 Scheduler
AndroidSchedulers.mainThread()	Android专用的，指定的操作将在 Android 主线程运行
Schedulers.from(executor)	使用指定的Executor作为调度器
Schedulers.newThread()	总是启用新线程，并在新线程执行操作。

EventBus:
使用 newCachedThreadPool，实现 前台线程通知

OKHTTP:
类似 newCachedThreadPool
实现： executor = new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory("OkHttp ConnectionPool", true));

Fresco
Default implementation of SerialExecutorService

Activity 中 setContentView() 与 addContentView() 的区别
如果多次调用 setContentView() ，则之后每次都会清空 mContentParent 容器。然后组装资源 layoutResID 。
如果多次调用 addContentView() ，则之后每次都会将 View 添加到 mContentParent 容器中。最后产生 View 的叠加效果。
这个 mContentParent 存在于 PhoneWindow 中。

Elevation 是静态的，所以你最好不要动态的去改变他。如果你想在 Z 轴上做动画的效果（如按下态或者静止态），你需要使用 Translation Z 属性。
Translation Z 是动态的，当你创建一个空白项目，并在其中增加一个按钮的时候，当你按下它你将会看到阴影变大了。实际上 Elevation 并没有变化，而是 Translation Z 属性在变化。这是 Android 使用默认的状态列表动画，更改 Z 属性。
Z Vaue = Elevation + TranslationZ

列表优化：
1、减少布局层级，避免过多的Item View的无用布局嵌套；
2、对于有图片的列表，要在滑动时对图片加以控制，即滑动时不加载图片，停止滑动之后再加载图片；
3、应当避免在Adapter的填充数据时做过多的计算，或者嵌套过多的逻辑判断。对于复杂的计算结果应当在Adapter填充数据之前计算完成；
4、尽管在数据Bean中完成对各种数据变换的操作，包括复杂的计算，比如将String转换成需要的SpannableStringBuilder等；
5、addViewInLayout()和removeViewInLayout()来减少onMeasure()和onLayout()的次数以节省性能开支（该方法中的preventRequestLayout参数，为true，添加View时不会触发onMeasure和onLayout操作）


============================================================
=====                 Android开发技术                  =====
============================================================
activity进程控制：
开启多进程方式：android:process，通过JNI在native层fork一个进程
android:process——默认进程名是包名，
android:process=":xyz"——为包名加+“:xyz”，其为私有进程，其他应用的组件不可以跑在同一进程中
android:process="com.abc"——com.abc，全局进程，其他应用可以通过shareUID方式跑在同一进程
多进程：同一进程的组件属于同一个虚拟机和同一个application，内存空间
1、静态成员变量失效，2、线程同步机制失效，3、SharePreference可靠性下降，4、application多次创建

Android系统会为每个应用分配一个唯一的UID,具有相同UID的应用才能共享数据，两个应用通过ShareUID跑在同一个进程中，需要这两个应用有相同的ShareUID并且签名相同。它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。

manifest
package：整个应用的包名，通过ComponentName来启动某个Activity
android:sharedUserId="android.uid.system"，将当前应用进程设置为系统级进程，需要在当前模块的MakeFile中添加LOCAL_CERTIFICATE := platform，然后在安卓源码环境下使用原生make命令编译才能生效
uses-permission：为我们的应用添加必须的权限。同时我们也可以该层声明自定义的权限。
<permission
    android:name="com.cold.permission.appfreeze"
    android:protectionLevel="signatureOrSystem"/>
protectionLevel：
normal：低风险权限，只要申请了就可以使用，安装时不需要用户确认；
dangerous：高风险权限，安装时需要用户的确认才可使用；
signature：只有当申请权限的应用程序的数字签名与声明此权限的应用程序的数字签名相同时（如果是申请系统权限，则需要与系统签名相同），才能将权限授给它；
signatureOrSystem：签名相同，或者申请权限的应用为系统应用（在system image中）。

android:theme：为当前应用的每个界面都默认设置一个主题，可以后续在activity标签层单独覆盖此Theme。
android:allowBackup：关闭应用程序数据的备份和恢复功能，注意该属性值默认为true，如果你不需要你的应用被恢复导致隐私数据暴露
android:hardwareAccelerated：开启硬件加速，一般应用不推介使用。就算非要使用也最好在某个Activity单独开启，避免过大的内存开销。
android:taskAffinity：设置Activity任务栈的名称,可忽略
android:configChanges：当我们的界面大小，方向，字体等config参数改变时，我们的Activity就会重新执行onCreate的生命周期。而当我们设置此属性后，就可以强制让Activity不重新启动，而是只会调用一次onConfigurationChanged方法

intent-filter：当我们通过intent去隐式调用一个Activity时，需要同时匹配注册activity中的action、category、data才能正常启动
action：隐式调用时intent必须setAction。一个过滤器中可以有多个action属性，只要我们的intent和其中任意一项equal则就算匹配成功
category：匹配时也必须和过滤器中定义的值相同，当我们不为intent主动地addCategory时，系统为帮我们默认添加一个值为"android.intent.category.DEFAULT"的category
反过来说，如果我们需要我们自己写的Activity能接受隐式intent启动，我们就必须在它的过滤器中添加"android.intent.category.DEFAULT"（深坑！），否则无法成功启动。
data：分为mimeType和URI路径两部分：mimeType指定媒体格式类型，音频、文件、图片都有特定的属性值。
URI则有android:scheme、android:host、android:port等属性组成，scheme代表模式（常用的有http,content,file,package），Host就是一个主机地址，Port则是端口号。
intent.setDataAndType(Uri.parse("content://com.android.externalstorage.documents"), "vnd.android.document/root");
meta-data：提供组件额外的数据用的，它本身是一个键值对，写在清单文件中之后，可以在代码中获取
android:excludeFromRecents：设置为true后，当用户按了“最近任务列表”时候，该activity不会出现在最近任务列表中，可达到隐藏应用的目的
receiver，permission：可以发送一些敏感的广播，只有添加了该permission的receiver才能接收到，而不让其他的应用收到；不加则所有有此action的接收者都能收到我们发出的广播
Intent intent = new Intent("com.android.settings.action.SWITH_AGED_MODE");
sendBroadcast(intent,"com.android.settings.permission.SWITH_SETTING");

AIDL
in：由客户端流向服务端，服务端不能改变客户端
out：服务端流向客户端，服务端改变，客户端改变
inout：双向流通

自定义View分为以下4类：
1、继承view重写onDraw方法
2、继承ViewGroup派生特殊的Layout
3、继承特定的View(比如TextView)
4、继承特殊的ViewGroup(比如LinearLayout)

自定义View须知：
1、让View支持wrap_content
2、如果有必要，让你的View支持padding
3、尽量不要在View中使用Handler，没必要
4、View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow
5、View带有滑动嵌套情形时，需要处理好滑动冲突

Android 系统中的API：
Formatter.formatFileSize(Context context, long sizeBytes)：格式化文件大小，将字节数据格式化为 B、KB、M 等单位的相应数据

view.performClick()：自动调用 View 点击事件。通常按钮等控件只有在用户点击时才能触发其点击事件

getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE)：设置安全窗口，禁用系统截屏
支付宝 App 的“向商家付款”的包含付款二维码的界面，微信付款界面不是这么做的，采用的是在 onResume() 生命周期方法中实时刷新付款二维码

@Override
public void onBackPressed() {
  Intent launcherIntent = new Intent(Intent.ACTION_MAIN);
  launcherIntent.addCategory(Intent.CATEGORY_HOME);
  startActivity(launcherIntent);
}
使用 Back 键返回桌面，但不关闭当前应用，而是使之进入后台

android:descendantFocusability:用于ViewGroup中，解决作为Parent的ViewGroup与Children View之间的焦点占用问题
android:duplicateParentState:是否将View自身的 drawable state 交给直接parent ViewGroup控制，值为 boolean 类型
android:fillViewport:ScrollView 的一个属性，用于设置内容部分是否填满屏幕，主要针对内容不足以填满屏幕的情况
android:adjustViewBounds:后者需要至少指定 ImageView 宽高中的一个属性，或者 maxHeight 之类的，然后另一个属性随之适配

缩略图
ThumbnailUtils createVideoThumbnail(String filePath, int kind)/extractThumbnail(Bitmap source, int width, int height)

GridLayoutManager构造方法中传入了一个spanCount,这里值为3
getSpanSize方法中，最后一个item占据2个span，其他占据一个span

Android 唯一设备号生成方案：通过获取到 IMEI、AndroidId、macAddress 进行拼接，再将拼接结果进行 MD5 转换，那么就可以得到一串 32 个字符的 16 进制数据

每一个枚举值都是一个对象,在使用它时会增加额外的内存消耗,所以枚举相比与 Integer 和 String 会占用更多的内存。
较多的使用 Enum 会增加 DEX 文件的大小,会造成运行时更多的开销,使我们的应用需要更多的空间。
解决方案：就是要将的@IntDef/@StringDef + @interface来进行限定参数
@IntDef({MAN, WOMEN}) //限定为MAN,WOMEN
@Retention(RetentionPolicy.SOURCE) //表示注解所存活的时间,在运行时,而不会存在. class 文件

Target
定义了Annotation所修饰的对象范围，取值：　
ElementType.CONSTRUCTOR:用于描述构造器
ElementType.FIELD:用于描述域
ElementType.LOCAL_VARIABLE:用于描述局部变量
ElementType.METHOD:用于描述方法
ElementType.PACKAGE:用于描述包
ElementType.PARAMETER:用于描述参数
ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明

Retention
定义了该Annotation被保留的时间长短，取值：
RetentionPoicy.SOURCE:注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；用于做一些检查性的操作，比如 @Override 和 @SuppressWarnings
RetentionPoicy.CLASS:注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；用于在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife）
RetentionPoicy.RUNTIME:注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；用于在运行时去动态获取注解信息。

Documented
标记注解，用于描述其它类型的注解应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化，不用赋值。

Inherited
标记注解，允许子类继承父类的注解。

如果成员名称是value，在赋值过程中可以简写。如果成员类型为数组，但是只赋值一个元素，则也可以简写。
1、@Target(value = {ElementType.ANNOTATION_TYPE})
2、@Target({ElementType.ANNOTATION_TYPE})
3、@Target(ElementType.ANNOTATION_TYPE)

Android SDK内置的注解
资源引用限制类：用于限制参数必须为对应的资源类型
@AnimRes @AnyRes @ArrayRes @AttrRes @BoolRes @ColorRes等
线程执行限制类：用于限制方法或者类必须在指定的线程执行
@AnyThread @BinderThread @MainThread @UiThread @WorkerThread
参数为空性限制类：用于限制参数是否可以为空
@NonNull @Nullable
类型范围限制类：用于限制标注值的值范围
@FloatRang @IntRange
类型定义类：用于限制定义的注解的取值集合
@IntDef @StringDef
其他的功能性注解：
@CallSuper @CheckResult @ColorInt @Dimension @Keep @Px @RequiresApi @RequiresPermission @RestrictTo @Size @VisibleForTesting

RxJava
1.subscribeOn影响是整条RxJava链路
2.observeOn只影响它下游的链路
3.连续调用subscribeOn是没有用的,只有第一次会生效
4.连续调用observeOn是有用的,会不断的切换线程。
5.在observeOn调用之后,subscribeOn的影响就会被observeOn抵消。换句话说,observeOn就是subscribeOn的"拦路虎"

// Using clear will clear all, but can accept new disposable
disposables.clear();
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();

SingleScheduler  使用newScheduledThreadPool线程池定义定时器，最大允许线程数为1 单线程，按照先进先出的顺序依次执行
ComputationScheduler  使用FixedSchedulerPool作为线程池，线程池数量为CPU数量 MAX_THREADS = cap(Runtime.getRuntime().availableProcessors(), Integer.getInteger(KEY_MAX_THREADS, 0));
IoScheduler  使用CachedWorkerPool作为线程池
NewThreadScheduler  创建NewThreadWorker SingleScheduler的executor是使用AtomicReference包装的ScheduledExecutorService。每次使用时，会调用executor.get()，NewThreadScheduler每次都会创建一个新的线程
特别需要的是 ComputationScheduler 和 IoScheduler 都是依赖线程池来维护线程的，区别就是 IoScheduler 线程池中的个数是无限的，由 prefix 和 incrementAndGet() 产生的递增值来决定线程的名字；而 ComputationScheduler 中则是一个固定线程数量的线程池，数据为CPU的数目，并且不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU


保持屏幕常亮：
getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
onResume() 和 onPause() 方法中，分别调用这两个方法。

WakeLock 是一个全局的资源，而 FLAG_KEEP_SCREEN_ON 只是一个和 window 相关的资源，作用范围更小了一些。
并且它比 WakeLock 更好的一点在于，它不需要额外的申请权限

Android6.0权限适配
如果使用的只是普通权限，也就是不涉及用户隐私的，比如蓝牙，网络访问等，这些权限属于普通权限，普通权限会在应用被安装的时候默认授予，用户不能拒绝，也不能取消
动态权限的申请可以有两种形态，一种是在程序的一开始将所有的权限都申请到，一种是需要的时候再去申请，不需要不申请
 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
 //判断该应用是否有写SD卡权限，如果没有再去申请
     if (ContextCompat.checkSelfPermission(MainActivity.this, permission.WRITE_EXTERNAL_STORAGE) !=
         PackageManager.PERMISSION_GRANTED) {
         ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission
         .WRITE_EXTERNAL_STORAGE}, 123);}
 }
// 调用requestPermissions会弹出对话框，用户做出选择之后的回调
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
//requestCode 是调用requestPermissions传入的123，当然你可以设置成其他值或者某个静态变量

这两个目录中的文件也会随着app的删除而清空
当系统版本大于等于4.4时，对通过上面4个API调用得到的目录进行文件的读写操作不需要申请SD卡的读写权限，所以6.0及以上系统使用时也不需要动态申请读写权限
Content.getExternalFilesDir(Environment.DIRECTORY_PICTURES); // /storage/emulated/0/Android/data/app_package_name/files/Pictures
Content.getExternalCacheDir(); // /storage/emulated/0/Android/data/app_package_name/cache
Content.getCacheDir(); //  /data/data/app_package_name/cache
Content.getFilesDir(); //  /data/data/app_package_name/files
/**
 * 获取SD卡缓存目录
 * @param context 上下文
 * @param type 文件夹类型 如果为空则返回 /storage/emulated/0/Android/data/app_package_name/cache
 *             否则返回对应类型的文件夹如Environment.DIRECTORY_PICTURES 对应的文件夹为 .../data/app_package_name/files/Pictures
 * {@link android.os.Environment#DIRECTORY_MUSIC},
 * {@link android.os.Environment#DIRECTORY_PODCASTS},
 * {@link android.os.Environment#DIRECTORY_RINGTONES},
 * {@link android.os.Environment#DIRECTORY_ALARMS},
 * {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
 * {@link android.os.Environment#DIRECTORY_PICTURES}, or
 * {@link android.os.Environment#DIRECTORY_MOVIES}.or 自定义文件夹名称
 * @return 缓存目录文件夹 或 null（无SD卡或SD卡挂载失败）
 */
public static File getExternalCacheDirectory(Context context,String type) {
    File appCacheDir = null;
    if( Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
        if (TextUtils.isEmpty(type)){
            appCacheDir = context.getExternalCacheDir();
        }else {
            appCacheDir = context.getExternalFilesDir(type);
        }

        if (appCacheDir == null){// 有些手机需要通过自定义目录
            appCacheDir = new File(Environment.getExternalStorageDirectory(),"Android/data/"+context.getPackageName()+"/cache/"+type);
        }

        if (appCacheDir == null){
            Log.e("getExternalDirectory","getExternalDirectory fail ,the reason is sdCard unknown exception !");
        }else {
            if (!appCacheDir.exists()&&!appCacheDir.mkdirs()){
                Log.e("getExternalDirectory","getExternalDirectory fail ,the reason is make directory fail !");
            }
        }
    }else {
        Log.e("getExternalDirectory","getExternalDirectory fail ,the reason is sdCard nonexistence or sdCard mount fail !");
    }
    return appCacheDir;
}

/**
 * 获取内存缓存目录
 * @param type 子目录，可以为空，为空直接返回一级目录
 * @return 缓存目录文件夹 或 null（创建目录文件失败）
 * 注：该方法获取的目录是能供当前应用自己使用，外部应用没有读写权限，如 系统相机应用
 */
public static File getInternalCacheDirectory(Context context,String type) {
    File appCacheDir = null;
    if (TextUtils.isEmpty(type)){
        appCacheDir = context.getCacheDir();// /data/data/app_package_name/cache
    }else {
        appCacheDir = new File(context.getFilesDir(),type);// /data/data/app_package_name/files/type
    }

    if (!appCacheDir.exists()&&!appCacheDir.mkdirs()){
        Log.e("getInternalDirectory","getInternalDirectory fail ,the reason is make directory fail !");
    }
    return appCacheDir;
}

adb shell am start -w packagename/activity
ThisTime表示一连串启动Activity的最后一个Activity的启动耗时；TotalTime表示新应用启动的耗时，包括新进程的启动和Activity的启动，但不包括前一个应用Activity pause的耗时。也就是说，开发者一般只要关心TotalTime即可，这个时间才是自己应用真正启动的耗时。



浏览器启动app
manifest：
 <intent-filter>
     <action android:name="android.intent.action.VIEW" />

     <category android:name="android.intent.category.DEFAULT" />
     <category android:name="android.intent.category.BROWSABLE" />

     <data android:scheme="wandaappktv" />
 </intent-filter>

activity:
Uri uri = intent.getData();
if (uri != null
        && Constants.OVERRIDE_SCHEME.equalsIgnoreCase(uri.getScheme())) {
    String path = uri.toString();
    if (path.startsWith(ACTION_PLAYER)) {
        String callingPackage = intent
                .getStringExtra(ShareCompat.EXTRA_CALLING_PACKAGE);
        String packageName = context.getPackageName();
        if (packageName.equals(callingPackage)) {
chrome
intent:HOST/URI-path // Optional host
#Intent;
package=[string];
action=[string];
category=[string];
component=[string];
scheme=[string];
end;
<pre name="code" class="html"><pre name="code" class="html"><a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;end">Do Whatever</a>
activity:
<activity android:name=".TestUrlScheme" >
            <intent-filter>
                <action android:name="android.intent.action.VIEW" /><!-- 显示数据 -->
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" /><!-- 定义成浏览器类型，有URL需要处理时会过滤 -->
                <data android:scheme="myapp" android:host="whatever" android:path="/" /><!-- 打开以whatever协议的URL,这个自己随便定义。 -->
            </intent-filter>
</activity>
传参的内容
<a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;S.name=Perico%20de%20los%20Palotes;I.age=35;end">Do Whatever</a> 
activity:
Bundle parametros = getIntent().getExtras();  
if (extras != null){  
    String name = extras.getString("name");  
    Integer age = extras.getInt("age"); 
    
    
buildTypes {
    debug {
        applicationIdSuffix '.debug'
        versionNameSuffix '-debug'
    }

    beta.initWith(buildTypes.debug)
    beta {
        applicationIdSuffix '.beta'
        versionNameSuffix '-beta'
    }
    
Library Module
library依赖于其它module时将默认使用release构建类型，如果要更改为我们自己的构建类型时，有两种方法：
defaultPublishConfig "googleBeta"
publishNonDefault true    compile project(path:':library', configuration:'demoDebug')

org.gradle.parallel=ture //并行构建启动
org.gradle.daemon=true //gradle守护进程
建议 : debug 状态下提高构建速度，可以将这两个选项打开。 但是真正在线上机器做 release 打包时还是关闭了吧

源自leakcanary代码：
public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
    PackageManager packageManager = context.getPackageManager();
    PackageInfo packageInfo;
    try {
      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
    } catch (Exception e) {
      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
      return false;
    }
    String mainProcess = packageInfo.applicationInfo.processName;

    ComponentName component = new ComponentName(context, serviceClass);
    ServiceInfo serviceInfo;
    try {
      serviceInfo = packageManager.getServiceInfo(component, 0);
    } catch (PackageManager.NameNotFoundException ignored) {
      // Service is disabled.
      return false;
    }

    if (serviceInfo.processName.equals(mainProcess)) {
      Log.e("AndroidUtils",
          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
      // Technically we are in the service process, but we're not in the service dedicated process.
      return false;
    }

    //查找当前进程名
    int myPid = android.os.Process.myPid();
    ActivityManager activityManager =
        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    ActivityManager.RunningAppProcessInfo myProcess = null;
    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
      if (process.pid == myPid) {
        myProcess = process;
        break;
      }
    }
    if (myProcess == null) {
      Log.e("AndroidUtils", "Could not find running process for " + myPid);
      return false;
    }

    return myProcess.processName.equals(serviceInfo.processName);
  }

电量数据收集
1、因为电量统计数据是持续的, 会非常大, 统计我们的待测试App之前先reset下, 连上设备, 命令行执行:
$ adb shell dumpsys batterystats --reset
Battery stats reset.

断开测试设备, 操作我们的待测试App.
重新连接设备, 使用adb命令导出相关统计数据:

// 此命令持续记录输出, 想要停止记录时按Ctrl+C退出.
$ adb bugreport > bugreport.txt

监听手机充电状态

// It is very easy to subscribe to changes to the battery state, but you can get the current 
// state by simply passing null in as your receiver. Nifty, isn't that? 
IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); 
Intent batteryStatus = this.registerReceiver(null, filter); 
int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1); 
boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC); 
if (acCharge) { Log.v(LOG_TAG,“The phone is charging!”); }

只有当前手机为AC充电状态时 才去执行一些非常耗电的操作
/** * This method checks for power by comparing the current battery state against all possible * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or * wireless charge. (Wireless charge was introduced in API Level 17.) */ 
private boolean checkForPower() {
 // It is very easy to subscribe to changes to the battery state, but you can get the current 
 // state by simply passing null in as your receiver. Nifty, isn't that? 
 IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); 
 Intent batteryStatus = this.registerReceiver(null, filter); 
 // There are currently three ways a device can be plugged in. We should check them all. 
 int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1); 
 boolean usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB); 
 boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC); 
 boolean wirelessCharge = false; 
 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
  wirelessCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_WIRELESS); 
 } return (usbCharge || acCharge || wirelessCharge); 
}

保持屏幕常亮
getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
另一个方式是在布局文件中使用android:keepScreenOn属性：作用和FLAG_KEEP_SCREEN_ON一样
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:keepScreenOn="true">
一般不需要人为的去掉FLAG_KEEP_SCREEN_ON的flag，windowManager会管理好程序进入后台回到前台的的操作。如果确实需要手动清掉常亮的flag，使用getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)

WakeLock
wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行
使用场景，是在使用后台服务在屏幕关闭情况下hold住CPU完成一些工作。 要使用唤醒锁，如果不使用唤醒锁来执行后台服务，不能保证因CPU休眠未来的某个时刻任务会停止
唤醒锁可划分为并识别四种用户唤醒锁：
标记值 	                  CPU 	屏幕 	键盘
PARTIAL_WAKE_LOCK       	开启 	关闭 	关闭
SCREEN_DIM_WAKE_LOCK    	开启 	变暗 	关闭
SCREEN_BRIGHT_WAKE_LOCK 	开启 	变亮 	关闭
FULL_WAKE_LOCK 	          开启 	变亮 	变亮  （废弃）
<uses-permission android:name="android.permission.WAKE_LOCK" />
PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE); 
WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,"MyWakelockTag"); 
wakeLock.acquire();
必须保证acquire和release是成对出现的

JobScheduler
JobScheduler 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。JobSchedule的宗旨就是把一些不是特别紧急的任务放到更合适的时机批量处理
好处：
避免频繁的唤醒硬件模块，造成不必要的电量消耗。
避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量；

GPS
GPS_PROVIDER:
GPS定位，利用GPS芯片通过卫星获得自己的位置信息。定位精准度高，一般在10米左右，耗电量大；但是在室内，GPS定位基本没用
NETWORK_PROVIDER：
网络定位，利用手机基站和WIFI节点的地址来大致定位位置，这种定位方式取决于服务器，即取决于将基站或WIF节点信息翻译成位置信息的服务器的能力。
PASSIVE_PROVIDER
被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接收到消息后直接读取就可以了。比如如果系统中已经安装了百度地图，高德地图(室内可以实现精确定位)，你只要使用它们定位过后，再使用这种方法在你的程序肯定是可以拿到比较精确的定位信息。

及时注销定位监听
在获取到定位之后或者程序处于后台时，注销定位监听，此时监听GPS传感器相当于执行no-op（无操作指令），用户不会有感知但是却耗电
public void onPause() {
 super.onPause(); 
 locationManager.removeListener(locationListener); 
} 
public void onResume(){
 super.onResume();
 locationManager.requestLocationUpdates(locationManager.getBestProvider(criteria, true),6000,100,locationListener); 
}

传感器
使用传感器，选择合适的采样率，越高的采样率类型则越费电
SENSOR_DELAY_NOMAL (200000微秒)
SENSOR_DELAY_UI (60000微秒)
SENSOR_DELAY_GAME (20000微秒)
SENSOR_DELAY_FASTEST (0微秒)


SpannableStringBuilder
start： 指定Span的开始位置
end： 指定Span的结束位置，并不包括这个位置。
flags：取值有如下四个
    Spannable. SPAN_INCLUSIVE_EXCLUSIVE：前面包括，后面不包括，即在文本前插入新的文本会应用该样式，而在文本后插入新文本不会应用该样式
    Spannable. SPAN_INCLUSIVE_INCLUSIVE：前面包括，后面包括，即在文本前插入新的文本会应用该样式，而在文本后插入新文本也会应用该样式
    Spannable. SPAN_EXCLUSIVE_EXCLUSIVE：前面不包括，后面不包括
    Spannable. SPAN_EXCLUSIVE_INCLUSIVE：前面不包括，后面包括
what： 对应的各种Span，不同的Span对应不同的样式。已知的可用类有：
    BackgroundColorSpan : 文本背景色
    ForegroundColorSpan : 文本颜色
    MaskFilterSpan : 修饰效果，如模糊(BlurMaskFilter)浮雕
    RasterizerSpan : 光栅效果
    StrikethroughSpan : 删除线
    SuggestionSpan : 相当于占位符
    UnderlineSpan : 下划线
    AbsoluteSizeSpan : 文本字体（绝对大小）
    DynamicDrawableSpan : 设置图片，基于文本基线或底部对齐。
    ImageSpan : 图片
    RelativeSizeSpan : 相对大小（文本字体）
    ScaleXSpan : 基于x轴缩放
    StyleSpan : 字体样式：粗体、斜体等
    SubscriptSpan : 下标（数学公式会用到）
    SuperscriptSpan : 上标（数学公式会用到）
    TextAppearanceSpan : 文本外貌（包括字体、大小、样式和颜色）
    TypefaceSpan : 文本字体
    URLSpan : 文本超链接
    ClickableSpan : 点击事件


 public class BuildTimeListener implements TaskExecutionListener, BuildListener {
    private Clock clock
    private times = []

    @Override
    void beforeExecute(Task task) {
        clock = new org.gradle.util.Clock()
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        def ms = clock.timeInMs
        times.add([ms, task.path])

        //task.project.logger.warn "${task.path} spend ${ms}ms"
    }

    @Override
    void buildFinished(BuildResult result) {
        println "Task spend time:"
        for (time in times) {
            if (time[0] >= 50) {
                printf "%7sms  %s\n", time
            }
        }
    }

    ......
}

project.gradle.addListener(new BuildTimeListener())


static boolean isMain() {
  return Looper.getMainLooper().getThread() == Thread.currentThread();
}

long before = Runtime.getRuntime().totalMemory() / 1024 - Runtime.getRuntime().freeMemory() / 1024;
long after = Runtime.getRuntime().totalMemory() / 1024 - Runtime.getRuntime().freeMemory() / 1024;


<receiver 
  android:enabled=["true" | "false"]
  //此 broadcastReceiver 能否接收其他 App 发出的广播
  //默认值是由 receiver 中有无 intent-filter 决定的：如果有 intent-filter，默认值为 true，否则为 false
  android:exported=["true" | "false"]
  android:icon="drawable resource"
  android:label="string resource"
  //继承 BroadcastReceiver 子类的类名
  android:name=".mBroadcastReceiver"
  //具有相应权限的广播发送者发送的广播才能被此 BroadcastReceiver 所接收；
  android:permission="string"
  // BroadcastReceiver 运行所处的进程
  // 默认为 App 的进程，可以指定独立的进程
  //注：Android 四大基本组件都可以通过此属性指定自己的独立进程
  android:process="string" >

  //用于指定此广播接收器将接收的广播类型
  //本示例中给出的是用于接收网络状态改变时发出的广播
   <intent-filter>
        <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
  </intent-filter>
</receiver>

@ViewDebug.ExportedProperty(category = "drawing")  
public boolean hasOverlappingRendering() {  
    return true;  
}
在android的View里有透明度的属性，当设置透明度setAlpha的时候，android里默认会把当前view绘制到offscreen buffer中，然后再显示出来。 这个offscreen buffer 可以理解为一个临时缓冲区，把当前View放进来并做透明度的转化，然后在显示到屏幕上


<meta-data 
	android:name="android.max_aspect"
	android:value="2.1"/>

max_aspect 属性表示 App 能够支持的最大屏幕比例，官方建议我们将该值设置为 2.1 或者更高的值。
**注意：**如果你没有使用 meta-data 标签设置 max_aspect 属性，同时 android:resizeableActivity 属性值为 true 的话，App 默认使用的最大 aspect 默认值为 1.8（大约 16:9 的样子）。
备注： resizeableActivity 属性在 targetSDKVersion 小于 24 的应用中值为 false，其他为 true。


<style name="AppTheme.NoActionBar">
    <!--状态栏颜色-->
    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
    <!--控制各个控件被选中时的颜色-->
    <item name="colorAccent">@color/colorAccent</item>
    <!--页面背景色-->
    <item name="android:windowBackground">@color/windowBackg</item>
    <!--底部导航栏颜色-->
    <item name="android:navigationBarColor">@color/navigationColor</item>
    <!--Appbar背景色-->
    <item name="android:colorPrimary">@color/colorPrimary</item>
    <!--ToolBar上的Title颜色-->
    <item name="android:textColorPrimary">@color/textColorPrimary</item>
    <!--各个控制控件的默认颜色-->
    <item name="android:colorControlNormal">@color/colorControlNormal</item>
</style>

Proguard：
当您加载了映射文件到 APK Analyzer时（点击 “Load Proguard mappings… “ 按钮）， 您可以在 DEX 视图树中看到一些额外功能：
所有的名字都是混淆前的（即您可以看到原始的名字），被 ProGuard 配置规则 kept 的包，类，方法和属性会显示成粗体
您可以开启 “Show removed nodes” 选项来看任何被 ProGuard 移除的内容（字体上会有删除线）。右击树上的一个节点可以让您生成一个 keep 规则以便您粘贴到您的配置文件中。

tools:text="@tools:sample/date/ddmmyy"
tools:text="@tools:sample/lorem/random"
tools:text="@tools:sample/full_names"
tools:text="@sample/users.json/data/city"

优化嵌套的RecyclerView
允许你可以给RecyclerVIew设置自定义的视图池：
public OuterRecyclerViewAdapter(List<Item> items) {
    //Constructor stuff
    viewPool = new RecyclerView.RecycledViewPool();
}
@Override
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    //Create viewHolder etc
    holder.innerRecyclerView.setRecycledViewPool(viewPool);
}

============================================================
=====                      网站                        =====
============================================================
生成带混淆配置的aar库： http://www.voidcn.com/blog/lihenair/article/p-6050531.html

Android 截屏方式整理： http://www.jianshu.com/p/63e29dc43a69

Android原生音量控制： http://blog.csdn.net/u013082948/article/details/65630085

android-ui：https://github.com/wasabeef/awesome-android-ui

Android软键盘的全面解析，让你不再怕控件被遮盖：http://blog.csdn.net/l540675759/article/details/74528641

2个函数终结状态栏6个疑难杂症：https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247486202&idx=1&sn=49b04f0ccacef9324dc4d8184c122cf4&chksm=96cdabb7a1ba22a153dc71a0872fc46f63cab1c60224088ab00cf798ec1d2dbf166032a491f2&mpshare=1&scene=23&srcid=0804LRef4fAzGVMgmUWhxgDs#rd

RxJava 线程模型分析：https://juejin.im/post/59a369586fb9a024851027af

Android 你不知道的霸道总裁模式：http://www.jianshu.com/p/06063c226ba0

一种边播边下的播放策略： https://mp.weixin.qq.com/s?__biz=MzI2OTQxMTM4OQ==&mid=2247485181&idx=1&sn=b0226b55629bdc5787cbdc71feecbbca&chksm=eae1f3afdd967ab9fe8a81eab348c1a1699a46284f7a45f7f30a8ee8279a565aaf91d39a2de8#rd

Android UI优化：http://yydcdut.com/2017/03/10/ui-optimize/

Android性能优化-电量优化: http://www.jianshu.com/p/ded0ed6fac3d

Android手动显示和隐藏软键盘方法总结 ：http://blog.csdn.net/ccpat/article/details/46717573

免费的字体：fonts.google.com/       www.1001freefonts.com/

不可思议的OOM：http://www.jianshu.com/p/e574f0ffdb42

Android中那些让你相见恨晚的类-接口-方法：http://blog.csdn.net/yayun0516/article/details/47360885

Android中图片压缩分析（下）：http://www.jianshu.com/p/c581112ca2b2

Android应用开发性能优化完全分析：http://blog.csdn.net/yanbober/article/details/48394201#t33

你不知道的Android进程化--进程信息：https://juejin.im/post/5a1f88baf265da43163cd8f4

探索安卓中有意义的动画！：https://segmentfault.com/a/1190000004182537

自定义View公式：https://juejin.im/post/5a30fd7c5188255ea95bf32f

android6.0进入Material Design时代：http://blog.csdn.net/cao861544325/article/details/48223587

Android WebView 全面干货指南：http://www.jianshu.com/p/fd61e8f4049e

Android截屏方案：https://juejin.im/post/5a33403b6fb9a045132abdb6

ViewPager刷新问题原理分析及解决方案（FragmentPagerAdapter+FragementStatePagerAdapter）:https://juejin.im/post/5a4c77455188252bca05411f

android dalvik heap 浅析 ：http://blog.csdn.net/cqupt_chen/article/details/11068129

2018 年初值得关注的 25 个新 Android 库和项目：https://www.oschina.net/translate/25-new-android-libraries-and-projects-2018

Android多点触控最佳实践：https://www.jianshu.com/p/f8ef2685716d

Android多个网络连接：https://juejin.im/post/5aa87dcbf265da23783ff52e

人脸识别 -- 活体检测(张嘴摇头识别)：https://juejin.im/post/5aaf0e68f265da237f1e168c

实现高性能微信朋友圈：https://juejin.im/post/5aeb21fc5188256737063d71

RxJava2 只看这一篇文章就够了：https://juejin.im/post/5b17560e6fb9a01e2862246f

Android刘海屏适配方案：https://juejin.im/post/5b120189e51d45068b495135
