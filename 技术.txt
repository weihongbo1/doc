HTTPS握手：
1、客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。
2、服务器SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。
3、客户利用服务器传过来的信息验证服务器的合法性，包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。验证没有通过，通讯将断开。
4、用户端随机产生一个用于后面通讯的“对称密码”，然后用证书中的公钥对其加密，然后将加密后的“预主密码”传给服务器。
5、如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。
6、如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。
7、服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。
8、客户端向服务器端发出信息，指明后面的数据通讯将使用的主密码为对称密钥，同时通知服务器客户端的握手过程结束。
9、服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。
10、SSL 的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。


ActivityManagerService组织回退栈时以ActivityRecord为基本单位，所有的ActivityRecord放在同一个ArrayList里，可以将mHistory看作一个栈对象，索引0所指的对象位于栈底，索引mHistory.size()-1所指的对象位于栈顶
Zygote进程孵化出新的应用进程后，会执行ActivityThread类的main方法.在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到ActivityManagerService，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。
ActivityThread的main方法执行后,应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法

静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
堆区： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。
堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组

成员变量全部存储与堆中，局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中

在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存

Java内存回收机制：
在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。

强   从来不会      对象的一般状态             jvm停止运行时终止
软   在内存不足时  联合ReferenceQueue构造有   内存不足时终止
                   效期短/内存大/生命周期长
                   的对象二级缓存
弱   在垃圾回收时  联合ReferenceQueue构造有   GC运行后终止
                   效期短/内存大/生命周期长
                   的对象一级缓存
虚   在垃圾回收时  联合ReferenceQueue构造跟   GC运行后终止
                   踪对象被垃圾回收期回收  

开启多进程方式：android:process，通过JNI在native层fork一个进程
android:process——默认进程名是包名，
android:process=":xyz"——为包名加+“:xyz”，其为私有进程，其他应用的组件不可以跑在同一进程中
android:process="com.abc"——com.abc，全局进程，其他应用可以通过shareUID方式跑在同一进程
多进程：同一进程的组件属于同一个虚拟机和同一个application，内存空间
1、静态成员变量失效，2、线程同步机制失效，3、SharePreference可靠性下降，4、application多次创建

Parcelable
describeContents方法：通常返回0，效值是CONTENTS_FILE_DESCRIPTOR(0x01)，指明这个Parcel的内容包含文件描述符，文件描述符就是操作文件的数据结构，获取到文件描述符可以完成所有文件相关的操作

Binder
客户端和服务端在同一进程，返回服务端的Stub本身，否则是Stub.proxy对象
最大线程数：15个
死亡代理：linkToDeath，当Binder死亡时，会收到通知
调用服务端/客户端的方法在当前线程中，然后挂起线程，收到返回数据唤醒
被调用的方法在Binder线程池中

文件共享
sharePreferences本身是文件共享，有一定缓存策略，内存中会保存一份缓存，在多进程模式下不可靠

Message
obj：只支持非空的系统实现Parcelable接口数据


AIDL
in：由客户端流向服务端，服务端不能改变客户端
out：服务端流向客户端，服务端改变，客户端改变
inout：双向流通
Dalvik
1、允许有限内存中同时运行多个虚拟机实例，并且每一个Dalvik作为独立进程——防止虚拟机崩溃时，所有程序都被关闭
2、应用每次运行的时候，字节码都需要通过即时编译器转换为机器码
Dalvik监视所有的程序，并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。第一次加载后会生成Cache文件，以提供下次快速加载。
Dalvik解释其采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对接。这样可以节省一个指令后进行查表的时间。

ART 2014androidL
1、应用第一次安装的时候，字节码就预先编译成机器码
2、机器码占用存储空间更大，
3、安装时间变长

Dalvik	执行时编译	安装快	开启慢	占用空间小
ART	安装时编译	安装慢	开启快	占用空间大

service的省电开发
1、查看service是否存活以及降低优先级
2、用IntentService代替Service开发
3、后台执行的定时任务Alarm机制，AndroidL后可以用JobScheduler代替
注意：从Android 4.4之后，Alarm任务的触发时间将会变得不准确
JobScheduler作为一个调度应用程序，负责当应用程序被唤醒时，提供适当的运行环境

网络方面，wifi更省电

TCP：“面向连接”就是在正式通信前必须要与对方建立起连接，一个TCP连接必须要经过三次“对话”才能建立起来
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

Android 沙箱实现了应用程序的相互隔离，用于对文件系统的实体访问进行控制，也可以对其他Android系统资源进行访问控制。
沙箱系统的原理主要基于Linux系统的UID/GID机制
在 Linux 中，一个用户 ID 识别一个给定用户;在 Android 上，一个用户 ID 识别一个应用程序
应用程序在安装时被分配用户 ID，应用程序在设备上的存续期间内，用户 ID 保持不变。权限是关于允许或限制应用程序(而不是用户)访问设备资源
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

浏览器启动app
manifest：
 <intent-filter>
     <action android:name="android.intent.action.VIEW" />

     <category android:name="android.intent.category.DEFAULT" />
     <category android:name="android.intent.category.BROWSABLE" />

     <data android:scheme="wandaappktv" />
 </intent-filter>
 
activity:
Uri uri = intent.getData();
if (uri != null
        && Constants.OVERRIDE_SCHEME.equalsIgnoreCase(uri.getScheme())) {
    String path = uri.toString();
    if (path.startsWith(ACTION_PLAYER)) {
        String callingPackage = intent
                .getStringExtra(ShareCompat.EXTRA_CALLING_PACKAGE);
        String packageName = context.getPackageName();
        if (packageName.equals(callingPackage)) {
chrome
intent:HOST/URI-path // Optional host  
#Intent;  
package=[string];  
action=[string];  
category=[string];  
component=[string];   
scheme=[string];  
end; 
<pre name="code" class="html"><pre name="code" class="html"><a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;end">Do Whatever</a> 
activity:
<activity android:name=".TestUrlScheme" >  
            <intent-filter>  
                <action android:name="android.intent.action.VIEW" /><!-- 显示数据 -->  
                <category android:name="android.intent.category.DEFAULT" />  
                <category android:name="android.intent.category.BROWSABLE" /><!-- 定义成浏览器类型，有URL需要处理时会过滤 -->  
                <data android:scheme="myapp" android:host="whatever" android:path="/" /><!-- 打开以whatever协议的URL,这个自己随便定义。 -->  
            </intent-filter>  
</activity>
传参的内容
<a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;S.name=Perico%20de%20los%20Palotes;I.age=35;end">Do Whatever</a> 
activity:
Bundle parametros = getIntent().getExtras();  
if (extras != null){  
    String name = extras.getString("name");  
    Integer age = extras.getInt("age"); 

android5.0特性
1、Material Design
2、动态替换Theme：在setContentView之前调用setTheme方法；设置了Theme，需要finish当前Activity，然后重启当前Activity，让Theme生效
3、View的高度：elevation用于阴影，translationZ用于属性动画，汇总顺序改为先绘制高度小的，然后再按添加顺序绘制
注意：View的颜色背景为透明，则不会显示出阴影效果；只有子View的大小比父View小时，阴影才能显示出来
4、View的轮廓与剪裁（在Android5.1以上）
outlineProvider：默认是background
none：即使设置了evaluation也不显示阴影
background：按背景来显示轮廓，如果background是颜色值，则轮廓就是view的大小，如果是shape，则按shape指定的形状作为轮廓
bounds: View的矩形大小作轮廓
paddedBounds: View的矩形大小减去padding的值后的大小作轮廓。
注意：如果background是图片，那只能通过代码setOutlineProvider()来指定轮廓
View的裁剪是指将View按照轮廓裁剪，能改变View的形状，先设置轮廓，再设置根据轮廓裁剪View，目前只支持矩形，圆形，圆角矩形的裁剪
5、Palette的使用：从一张图片中拾取颜色
6、水波纹动画，自定义水波纹动画以及状态选择器动画
水波纹动画：在Android5.0以上默认自带
自定义水波纹动画：使用ViewAnimationUtils创建圆形水波纹动画，使用ripple标签或者RippleDrawable可以更改控件水波纹动画颜色
状态选择器动画：通过stateListAnimator属性指定状态选择器的动画
7、CardView的使用：CardLayout拥有高度和阴影，以及轮廓裁剪，圆角等功能
8、RecyclerView的使用
9、ToolBar的使用：用来代替ActionBar，但是比ActionBar更加灵活
10、Android 5.0新特性的向下兼容，通过Support Library使用，使用新API的布局放在res/layout-v21 res/drawable-v21 res/values-v21中

Android 6.0新控件
1、TextInputLayout的使用
2、FloatingActionButton的使用
3、Snackbar的使用
4、TabLayout的使用
5、CoordinatorLayout的使用

1、将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。
2、如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。
3、Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。
第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。

多进程的优势：
1、提高各个进程的稳定性，单一进程崩溃后不影响整个程序。
2、对于内存的时候更可控，可以通过手工释放进程，达到内存优化目的。
3、基于独立的JVM，各个模块可以充分解耦。
4、只保留daemon进程的情况下，会使应用存活时间更长，不容易被回收掉。

空进程存活时长： MAX_EMPTY_TIME = 30min
(缓存+空)进程个数上限：MAX_CACHED_APPS = SystemProperties.getInt(“sys.fw.bg_apps_limit”,32) = 32(默认)；
空进程个数上限：MAX_EMPTY_APPS = computeEmptyProcessLimit(MAX_CACHED_APPS) = MAX_CACHED_APPS/2 = 16；
trim空进程个数上限：TRIM_EMPTY_APPS = computeTrimEmptyApps() = MAX_EMPTY_APPS/2 = 8；
trim缓存进程个数上限：TRIM_CACHED_APPS = computeTrimCachedApps() = MAX_CACHED_APPS-MAX_EMPTY_APPS)/3 = 5;
TRIM_CRITICAL_THRESHOLD = 3;

adj:adj<5的应用不会被杀掉
前台进程0  可感知进程（前台service）2  服务进程（后台service）5  上一个app进程（返回键）7  测试（0 2 7home 9back）
前台进程：
拥有用户正在交互的 Activity（已调用onResume()）
拥有某个 Service，后者绑定到用户正在交互的 Activity
拥有正在“前台”运行的 Service（服务已调用 startForeground()）
拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
拥有正执行其 onReceive() 方法的 BroadcastReceiver

可视进程：
拥有不在前台、但仍对用户可见的 Activity（已调用onPause()）。
拥有绑定到可见（或前台）Activity 的 Service

服务进程：正在运行startService()方法启动的服务，且不属于上述两个更高类别进程的进程。

后台进程：对用户不可见的Activity的进程（已调用Activity的onStop()方法）

空进程：不含任何活动应用组件的进程

进程包括：
前台进程（foreground）可见进程（visible）次要服务（secondary server）后台进程（hidden）内容供应节点（content provider）空进程（empty）

按HOME键，看起来似乎是退出了，但是其实这个软件并没有被关闭，而是转为了后台程序
按退出键，看起来也是退出没错，但这个软件其实是被转为了空置程序

1、进程名以":"开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以":"开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。
2、Android系统会为每个应用分配一个唯一的UID,具有相同UID的应用才能共享数据，两个应用通过ShareUID跑在同一个进程中，需要这两个应用有相同的ShareUID并且签名相同。它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。

增量更新
增量更新的流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的）
1、用户手机上提取当前安装应用的apk；2、如何利用old.apk和new.apk生成增量文件；3、增加文件与1.中的old.apk合并，然后安装

manifest 
package：整个应用的包名，通过ComponentName来启动某个Activity
android:sharedUserId="android.uid.system"，将当前应用进程设置为系统级进程，需要在当前模块的MakeFile中添加LOCAL_CERTIFICATE := platform，然后在安卓源码环境下使用原生make命令编译才能生效
uses-permission：为我们的应用添加必须的权限。同时我们也可以该层声明自定义的权限。
  <permission
      android:name="com.cold.permission.appfreeze"
      android:protectionLevel="signatureOrSystem"/>

android:theme：为当前应用的每个界面都默认设置一个主题，可以后续在activity标签层单独覆盖此Theme。
android:allowBackup：关闭应用程序数据的备份和恢复功能，注意该属性值默认为true，如果你不需要你的应用被恢复导致隐私数据暴露
android:hardwareAccelerated：开启硬件加速，一般应用不推介使用。就算非要使用也最好在某个Activity单独开启，避免过大的内存开销。
android:taskAffinity：设置Activity任务栈的名称,可忽略
android:configChanges：当我们的界面大小，方向，字体等config参数改变时，我们的Activity就会重新执行onCreate的生命周期。而当我们设置此属性后，就可以强制让Activity不重新启动，而是只会调用一次onConfigurationChanged方法

intent-filter：当我们通过intent去隐式调用一个Activity时，需要同时匹配注册activity中的action、category、data才能正常启动
action：隐式调用时intent必须setAction。一个过滤器中可以有多个action属性，只要我们的itent和其中任意一项equal则就算匹配成功
category：匹配时也必须和过滤器中定义的值相同，当我们不为intent主动地addCategory时，系统为帮我们默认添加一个值为"android.intent.category.DEFAULT"的category
反过来说，如果我们需要我们自己写的Activity能接受隐式intent启动，我们就必须在它的过滤器中添加"android.intent.category.DEFAULT"（深坑！），否则无法成功启动。
data：分为mimeType和URI路径两部分：mimeType指定媒体格式类型，音频、文件、图片都有特定的属性值。
URI则有android:scheme、android:host、android:port等属性组成，scheme代表模式（常用的有http,content,file,package），Host就是一个主机地址，Port则是端口号。
intent.setDataAndType(Uri.parse("content://com.android.externalstorage.documents"), "vnd.android.document/root");

meta-data：提供组件额外的数据用的，它本身是一个键值对，写在清单文件中之后，可以在代码中获取
android:excludeFromRecents：设置为true后，当用户按了“最近任务列表”时候，该activity不会出现在最近任务列表中，可达到隐藏应用的目的

receiver，permission：可以发送一些敏感的广播，只有添加了该permission的receiver才能接收到，而不让其他的应用收到；不加则所有有此action的接收者都能收到我们发出的广播
Intent intent = new Intent("com.android.settings.action.SWITH_AGED_MODE");
sendBroadcast(intent,"com.android.settings.permission.SWITH_SETTING");


折半查找
        int low = 0;
        int high = sz.length - 1;

        while (low <= high) {
            int middle = (low + high) / 2;
            if(sz[middle] == key){
                return middle;
            }else if(sz[middle] > key){
                high = middle - 1;
            }else {
                low = middle + 1;
            }
        }
        return -1;

jvm：
JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区

程序计数器：一块较小的内存空间，它是当前线程所执行的字节码的行号指示器（么有规定任何OOM）
通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能，每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响

Java虚拟机栈：在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中

GC的两种判定方法：引用计数与引用链
GC的三种收集方法：标记清除、标记整理、复制算法
标记清除：分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。它的主要缺点：1、标记和清除过程效率不高；2、标记清除之后会产生大量不连续的内存碎片。
标记整理：标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。
复制算法，它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。主要缺点：内存缩小为原来的一半。

Window是一个抽象类，它的具体实现是PhoneWindow。WindowManager是外界访问Window的入口，Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的，因此Window实际是View的直接管理者

Window有三种类型，分别是应用Window、子Window和系统Window。
应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。
系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。
在三类Window中，应用Window的层级范围是1~99，子Window的层级范围是1000~1999，系统Window的层级范围是2000~2999，这些层级属性范围对应着WindowManager.LayoutParams的type参数。

如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：
mLayoutParams.type = LayoutParams.TYPE_SYSTEM_ERROR

Window是以View的形式存在，对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。无法直接访问Window，对Window的访问必须通过WindowManager。

WindowManagerGlobal的addView方法分为如下几步：
1、检查参数是否合法，如果是子Window那么还需要调整一些布局参数
2、创建ViewRootImpl并将View添加到列表中
3、通过ViewRootImpl来更新界面并完成Window的添加过程

dispatchDetachedFromWindow方法主要做四件事：
1、垃圾回收的工作，比如清除数据和消息，移除回调。
2、通过Session的remove方法删除Window，mWindowSession.remove(mWindow)，这同样是一个IPC过程，最终会调用WindowManagerService的removeWindow方法
3、调用View的dispatchDetachedFromWindow方法，在内部调用View的onDetachedFromWindow()以及onDetachedFromWindowInternal()。
4、调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews，需要将当前Window所关联的这三类对象从列表中删除。

Activity的Window创建过程
1、由ActivityThread中的performLaunchActivity()来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用其attach方法为其关联运行过程中所依赖的一系列上下文环境变量。
2、Activity实现了Window的Callback接口，当Window接收到外界的状态变化时就会调用Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等。
3、Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的。 PhoneWindow方法大致遵循如下几个步骤：
    如果没有DecorView，那么就创建它
    将View添加到DecorView的mContentParent中
    回调Activity的onCreateChanged方法通知Activity视图已经发生改变

Dialog的Window创建过程，有如下步骤：
1、创建Window:Diolog中Window的创建同样是通过PolicyManager的makeNewWindow方法来完成的，创建后的对象实际上就是PhoneWindow。
2、初始化DecorView并将Dialog的视图添加到DecorView中
3、将DecorView添加到Window中并显示：普通的Dialog有一个特殊之处，就是必须采用Activity的Context，如果采用Application的Context，那么就会报错。（应用token只有Activity拥有，所以这里只需要Activity作为Context来显示对话框即可）。
service：必须在 Manifest 里面注册系统权限（<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />），在显示 dialog 的时候必须要加一个 flag（WindowManager.LayoutParams.TYPE_SYSTEM_ALERT）

Toast的Window创建过程
1、在Toast的内部有两类IPC过程，第一类是Toast访问NotificationManagerService，第二类是NotificationManagerService回调Toast里的TN接口。
2、Toast属于系统Window，它内部的视图由两种方式指定：一种是系统默认的演示，另一种是通过setView方法来指定一个自定义的View
3、Toast具有定时取消功能，所以系统采用了Handler。Toast的显示和隐藏是IPC过程，都需要NotificationManagerService（NMS）来实现，在Toast和NMS进行IPC过程时，NMS会跨进程回调Toast中的TN类中的方法，TN类是一个Binder类，运行在Binder线程池中，所以需要通过Handler将其切换到当前发送Toast请求所在的线程，所以Toast无法在没有Looper的线程中弹出。
4、对于非系统应用来说，mToastQueue最多能同时存在50个ToastRecord，这样做是为了防止DOS(Denial of Service，拒绝服务)。因为如果某个应用弹出太多的Toast会导致其他应用没有机会弹出Toast。
非UI线程中显示Toast：
        Looper.prepare();  
        Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_SHORT).show();  
        Looper.loop();  

自定义View分为以下4类：
1、继承view重写onDraw方法
2、继承ViewGroup派生特殊的Layout
3、继承特定的View(比如TextView)
4、继承特殊的ViewGroup(比如LinearLayout)

自定义View须知：
1、让View支持wrap_content
2、如果有必要，让你的View支持padding
3、尽量不要在View中使用Handler，没必要
4、View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow
5、View带有滑动嵌套情形时，需要处理好滑动冲突

DOM,SAX,PULL三种解析方式:
DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机
SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。
PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。

JDK 1.7特性
然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(\<>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码

JDK 1.8特性
java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性： 
Lambda 表达式，允许像对象一样传递匿名函数 
Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 
Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 
扩展方法，现在，接口中可以有静态、默认方法。 
重复注解，现在你可以将相同的注解在同一类型上使用多次。

Android 系统中的API：
Formatter.formatFileSize(Context context, long sizeBytes)：格式化文件大小，将字节数据格式化为 B、KB、M 等单位的相应数据
view.performClick()：自动调用 View 点击事件。通常按钮等控件只有在用户点击时才能触发其点击事件
getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE)：设置安全窗口，禁用系统截屏
支付宝 App 的“向商家付款”的包含付款二维码的界面，微信付款界面不是这么做的，采用的是在 onResume() 生命周期方法中实时刷新付款二维码

  @Override
  public void onBackPressed() {
    Intent launcherIntent = new Intent(Intent.ACTION_MAIN);
    launcherIntent.addCategory(Intent.CATEGORY_HOME);
    startActivity(launcherIntent);
  }
  使用 Back 键返回桌面，但不关闭当前应用，而是使之进入后台
缩略图
ThumbnailUtils createVideoThumbnail(String filePath, int kind)/extractThumbnail(Bitmap source, int width, int height)

android:descendantFocusability:用于 ViewGroup 中，解决作为 Parent 的 ViewGroup 与 Children View 之间的焦点占用问题
android:duplicateParentState:是否将 View 自身的 drawable state 交给直接 parent ViewGroup 控制，值为 boolean 类型
android:fillViewport:ScrollView 的一个属性，用于设置内容部分是否填满屏幕，主要针对内容不足以填满屏幕的情况
android:adjustViewBounds:后者需要至少指定 ImageView 宽高中的一个属性，或者 maxHeight 之类的，然后另一个属性随之适配
