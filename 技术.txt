HTTPS握手：
1、客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。
2、服务器SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。
3、客户利用服务器传过来的信息验证服务器的合法性，包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。验证没有通过，通讯将断开。
4、用户端随机产生一个用于后面通讯的“对称密码”，然后用证书中的公钥对其加密，然后将加密后的“预主密码”传给服务器。
5、如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。
6、如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。
7、服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。
8、客户端向服务器端发出信息，指明后面的数据通讯将使用的主密码为对称密钥，同时通知服务器客户端的握手过程结束。
9、服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。
10、SSL 的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。


ActivityManagerService组织回退栈时以ActivityRecord为基本单位，所有的ActivityRecord放在同一个ArrayList里，可以将mHistory看作一个栈对象，索引0所指的对象位于栈底，索引mHistory.size()-1所指的对象位于栈顶
Zygote进程孵化出新的应用进程后，会执行ActivityThread类的main方法.在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到ActivityManagerService，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。
ActivityThread的main方法执行后,应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法

静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
堆区： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。
堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组

成员变量全部存储与堆中，局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中

在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存

Java内存回收机制：
在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。

强   从来不会      对象的一般状态             jvm停止运行时终止
软   在内存不足时  联合ReferenceQueue构造有   内存不足时终止
                   效期短/内存大/生命周期长
                   的对象二级缓存
弱   在垃圾回收时  联合ReferenceQueue构造有   GC运行后终止
                   效期短/内存大/生命周期长
                   的对象一级缓存
虚   在垃圾回收时  联合ReferenceQueue构造跟   GC运行后终止
                   踪对象被垃圾回收期回收  

开启多进程方式：android:process，通过JNI在native层fork一个进程
android:process——默认进程名是包名，
android:process=":xyz"——为包名加+“:xyz”，其为私有进程，其他应用的组件不可以跑在同一进程中
android:process="com.abc"——com.abc，全局进程，其他应用可以通过shareUID方式跑在同一进程
多进程：同一进程的组件属于同一个虚拟机和同一个application，内存空间
1、静态成员变量失效，2、线程同步机制失效，3、SharePreference可靠性下降，4、application多次创建

Parcelable
describeContents方法：通常返回0，效值是CONTENTS_FILE_DESCRIPTOR(0x01)，指明这个Parcel的内容包含文件描述符，文件描述符就是操作文件的数据结构，获取到文件描述符可以完成所有文件相关的操作

Binder
客户端和服务端在同一进程，返回服务端的Stub本身，否则是Stub.proxy对象
最大线程数：15个
死亡代理：linkToDeath，当Binder死亡时，会收到通知
调用服务端/客户端的方法在当前线程中，然后挂起线程，收到返回数据唤醒
被调用的方法在Binder线程池中

文件共享
sharePreferences本身是文件共享，有一定缓存策略，内存中会保存一份缓存，在多进程模式下不可靠

Message
obj：只支持非空的系统实现Parcelable接口数据


AIDL
in：由客户端流向服务端，服务端不能改变客户端
out：服务端流向客户端，服务端改变，客户端改变
inout：双向流通
Dalvik
1、允许有限内存中同时运行多个虚拟机实例，并且每一个Dalvik作为独立进程——防止虚拟机崩溃时，所有程序都被关闭
2、应用每次运行的时候，字节码都需要通过即时编译器转换为机器码
Dalvik监视所有的程序，并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。第一次加载后会生成Cache文件，以提供下次快速加载。
Dalvik解释其采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对接。这样可以节省一个指令后进行查表的时间。

ART 2014androidL
1、应用第一次安装的时候，字节码就预先编译成机器码
2、机器码占用存储空间更大，
3、安装时间变长

Dalvik	执行时编译	安装快	开启慢	占用空间小
ART	安装时编译	安装慢	开启快	占用空间大

service的省电开发
1、查看service是否存活以及降低优先级
2、用IntentService代替Service开发
3、后台执行的定时任务Alarm机制，AndroidL后可以用JobScheduler代替
注意：从Android 4.4之后，Alarm任务的触发时间将会变得不准确
JobScheduler作为一个调度应用程序，负责当应用程序被唤醒时，提供适当的运行环境

网络方面，wifi更省电

TCP：“面向连接”就是在正式通信前必须要与对方建立起连接，一个TCP连接必须要经过三次“对话”才能建立起来
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

Android 沙箱实现了应用程序的相互隔离，用于对文件系统的实体访问进行控制，也可以对其他Android系统资源进行访问控制。
沙箱系统的原理主要基于Linux系统的UID/GID机制
在 Linux 中，一个用户 ID 识别一个给定用户;在 Android 上，一个用户 ID 识别一个应用程序
应用程序在安装时被分配用户 ID，应用程序在设备上的存续期间内，用户 ID 保持不变。权限是关于允许或限制应用程序(而不是用户)访问设备资源
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

浏览器启动app
manifest：
 <intent-filter>
     <action android:name="android.intent.action.VIEW" />

     <category android:name="android.intent.category.DEFAULT" />
     <category android:name="android.intent.category.BROWSABLE" />

     <data android:scheme="wandaappktv" />
 </intent-filter>
 
activity:
Uri uri = intent.getData();
if (uri != null
        && Constants.OVERRIDE_SCHEME.equalsIgnoreCase(uri.getScheme())) {
    String path = uri.toString();
    if (path.startsWith(ACTION_PLAYER)) {
        String callingPackage = intent
                .getStringExtra(ShareCompat.EXTRA_CALLING_PACKAGE);
        String packageName = context.getPackageName();
        if (packageName.equals(callingPackage)) {
chrome
intent:HOST/URI-path // Optional host  
#Intent;  
package=[string];  
action=[string];  
category=[string];  
component=[string];   
scheme=[string];  
end; 
<pre name="code" class="html"><pre name="code" class="html"><a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;end">Do Whatever</a> 
activity:
<activity android:name=".TestUrlScheme" >  
            <intent-filter>  
                <action android:name="android.intent.action.VIEW" /><!-- 显示数据 -->  
                <category android:name="android.intent.category.DEFAULT" />  
                <category android:name="android.intent.category.BROWSABLE" /><!-- 定义成浏览器类型，有URL需要处理时会过滤 -->  
                <data android:scheme="myapp" android:host="whatever" android:path="/" /><!-- 打开以whatever协议的URL,这个自己随便定义。 -->  
            </intent-filter>  
</activity>
传参的内容
<a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;S.name=Perico%20de%20los%20Palotes;I.age=35;end">Do Whatever</a> 
activity:
Bundle parametros = getIntent().getExtras();  
if (extras != null){  
    String name = extras.getString("name");  
    Integer age = extras.getInt("age"); 

android5.0特性
1、Material Design
2、动态替换Theme：在setContentView之前调用setTheme方法；设置了Theme，需要finish当前Activity，然后重启当前Activity，让Theme生效
3、View的高度：elevation用于阴影，translationZ用于属性动画，汇总顺序改为先绘制高度小的，然后再按添加顺序绘制
注意：View的颜色背景为透明，则不会显示出阴影效果；只有子View的大小比父View小时，阴影才能显示出来
4、View的轮廓与剪裁（在Android5.1以上）
outlineProvider：默认是background
none：即使设置了evaluation也不显示阴影
background：按背景来显示轮廓，如果background是颜色值，则轮廓就是view的大小，如果是shape，则按shape指定的形状作为轮廓
bounds: View的矩形大小作轮廓
paddedBounds: View的矩形大小减去padding的值后的大小作轮廓。
注意：如果background是图片，那只能通过代码setOutlineProvider()来指定轮廓
View的裁剪是指将View按照轮廓裁剪，能改变View的形状，先设置轮廓，再设置根据轮廓裁剪View，目前只支持矩形，圆形，圆角矩形的裁剪
5、Palette的使用：从一张图片中拾取颜色
6、水波纹动画，自定义水波纹动画以及状态选择器动画
水波纹动画：在Android5.0以上默认自带
自定义水波纹动画：使用ViewAnimationUtils创建圆形水波纹动画，使用ripple标签或者RippleDrawable可以更改控件水波纹动画颜色
状态选择器动画：通过stateListAnimator属性指定状态选择器的动画
7、CardView的使用：CardLayout拥有高度和阴影，以及轮廓裁剪，圆角等功能
8、RecyclerView的使用
9、ToolBar的使用：用来代替ActionBar，但是比ActionBar更加灵活
10、Android 5.0新特性的向下兼容，通过Support Library使用，使用新API的布局放在res/layout-v21 res/drawable-v21 res/values-v21中

Android 6.0新控件
1、TextInputLayout的使用
2、FloatingActionButton的使用
3、Snackbar的使用
4、TabLayout的使用
5、CoordinatorLayout的使用

1、将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。
2、如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。
3、Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。
第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。

多进程的优势：
1、提高各个进程的稳定性，单一进程崩溃后不影响整个程序。
2、对于内存的时候更可控，可以通过手工释放进程，达到内存优化目的。
3、基于独立的JVM，各个模块可以充分解耦。
4、只保留daemon进程的情况下，会使应用存活时间更长，不容易被回收掉。

空进程存活时长： MAX_EMPTY_TIME = 30min
(缓存+空)进程个数上限：MAX_CACHED_APPS = SystemProperties.getInt(“sys.fw.bg_apps_limit”,32) = 32(默认)；
空进程个数上限：MAX_EMPTY_APPS = computeEmptyProcessLimit(MAX_CACHED_APPS) = MAX_CACHED_APPS/2 = 16；
trim空进程个数上限：TRIM_EMPTY_APPS = computeTrimEmptyApps() = MAX_EMPTY_APPS/2 = 8；
trim缓存进程个数上限：TRIM_CACHED_APPS = computeTrimCachedApps() = MAX_CACHED_APPS-MAX_EMPTY_APPS)/3 = 5;
TRIM_CRITICAL_THRESHOLD = 3;

adj:adj<5的应用不会被杀掉
前台进程0  可感知进程（前台service）2  服务进程（后台service）5  上一个app进程（返回键）7  测试（0 2 7home 9back）
前台进程：
拥有用户正在交互的 Activity（已调用onResume()）
拥有某个 Service，后者绑定到用户正在交互的 Activity
拥有正在“前台”运行的 Service（服务已调用 startForeground()）
拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
拥有正执行其 onReceive() 方法的 BroadcastReceiver

可视进程：
拥有不在前台、但仍对用户可见的 Activity（已调用onPause()）。
拥有绑定到可见（或前台）Activity 的 Service

服务进程：正在运行startService()方法启动的服务，且不属于上述两个更高类别进程的进程。

后台进程：对用户不可见的Activity的进程（已调用Activity的onStop()方法）

空进程：不含任何活动应用组件的进程

进程包括：
前台进程（foreground）可见进程（visible）次要服务（secondary server）后台进程（hidden）内容供应节点（content provider）空进程（empty）

按HOME键，看起来似乎是退出了，但是其实这个软件并没有被关闭，而是转为了后台程序
按退出键，看起来也是退出没错，但这个软件其实是被转为了空置程序

1、进程名以":"开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以":"开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。
2、Android系统会为每个应用分配一个唯一的UID,具有相同UID的应用才能共享数据，两个应用通过ShareUID跑在同一个进程中，需要这两个应用有相同的ShareUID并且签名相同。它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。

增量更新
增量更新的流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的）
1、用户手机上提取当前安装应用的apk；2、如何利用old.apk和new.apk生成增量文件；3、增加文件与1.中的old.apk合并，然后安装

manifest 
package：整个应用的包名，通过ComponentName来启动某个Activity
android:sharedUserId="android.uid.system"，将当前应用进程设置为系统级进程，需要在当前模块的MakeFile中添加LOCAL_CERTIFICATE := platform，然后在安卓源码环境下使用原生make命令编译才能生效
uses-permission：为我们的应用添加必须的权限。同时我们也可以该层声明自定义的权限。
  <permission
      android:name="com.cold.permission.appfreeze"
      android:protectionLevel="signatureOrSystem"/>

android:theme：为当前应用的每个界面都默认设置一个主题，可以后续在activity标签层单独覆盖此Theme。
android:allowBackup：关闭应用程序数据的备份和恢复功能，注意该属性值默认为true，如果你不需要你的应用被恢复导致隐私数据暴露
android:hardwareAccelerated：开启硬件加速，一般应用不推介使用。就算非要使用也最好在某个Activity单独开启，避免过大的内存开销。
android:taskAffinity：设置Activity任务栈的名称,可忽略
android:configChanges：当我们的界面大小，方向，字体等config参数改变时，我们的Activity就会重新执行onCreate的生命周期。而当我们设置此属性后，就可以强制让Activity不重新启动，而是只会调用一次onConfigurationChanged方法

intent-filter：当我们通过intent去隐式调用一个Activity时，需要同时匹配注册activity中的action、category、data才能正常启动
action：隐式调用时intent必须setAction。一个过滤器中可以有多个action属性，只要我们的itent和其中任意一项equal则就算匹配成功
category：匹配时也必须和过滤器中定义的值相同，当我们不为intent主动地addCategory时，系统为帮我们默认添加一个值为"android.intent.category.DEFAULT"的category
反过来说，如果我们需要我们自己写的Activity能接受隐式intent启动，我们就必须在它的过滤器中添加"android.intent.category.DEFAULT"（深坑！），否则无法成功启动。
data：分为mimeType和URI路径两部分：mimeType指定媒体格式类型，音频、文件、图片都有特定的属性值。
URI则有android:scheme、android:host、android:port等属性组成，scheme代表模式（常用的有http,content,file,package），Host就是一个主机地址，Port则是端口号。
intent.setDataAndType(Uri.parse("content://com.android.externalstorage.documents"), "vnd.android.document/root");

meta-data：提供组件额外的数据用的，它本身是一个键值对，写在清单文件中之后，可以在代码中获取
android:excludeFromRecents：设置为true后，当用户按了“最近任务列表”时候，该activity不会出现在最近任务列表中，可达到隐藏应用的目的

receiver，permission：可以发送一些敏感的广播，只有添加了该permission的receiver才能接收到，而不让其他的应用收到；不加则所有有此action的接收者都能收到我们发出的广播
Intent intent = new Intent("com.android.settings.action.SWITH_AGED_MODE");
sendBroadcast(intent,"com.android.settings.permission.SWITH_SETTING");


折半查找
        int low = 0;
        int high = sz.length - 1;

        while (low <= high) {
            int middle = (low + high) / 2;
            if(sz[middle] == key){
                return middle;
            }else if(sz[middle] > key){
                high = middle - 1;
            }else {
                low = middle + 1;
            }
        }
        return -1;

jvm：
JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区

程序计数器：一块较小的内存空间，它是当前线程所执行的字节码的行号指示器（么有规定任何OOM）
通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能，每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响

Java虚拟机栈：在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中

Window是一个抽象类，它的具体实现是PhoneWindow。WindowManager是外界访问Window的入口，Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的，因此Window实际是View的直接管理者

Window有三种类型，分别是应用Window、子Window和系统Window。
应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。
系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。
在三类Window中，应用Window的层级范围是1~99，子Window的层级范围是1000~1999，系统Window的层级范围是2000~2999，这些层级属性范围对应着WindowManager.LayoutParams的type参数。

如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：
mLayoutParams.type = LayoutParams.TYPE_SYSTEM_ERROR

Window是以View的形式存在，对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。无法直接访问Window，对Window的访问必须通过WindowManager。

WindowManagerGlobal的addView方法分为如下几步：
1、检查参数是否合法，如果是子Window那么还需要调整一些布局参数
2、创建ViewRootImpl并将View添加到列表中
3、通过ViewRootImpl来更新界面并完成Window的添加过程

dispatchDetachedFromWindow方法主要做四件事：
1、垃圾回收的工作，比如清除数据和消息，移除回调。
2、通过Session的remove方法删除Window，mWindowSession.remove(mWindow)，这同样是一个IPC过程，最终会调用WindowManagerService的removeWindow方法
3、调用View的dispatchDetachedFromWindow方法，在内部调用View的onDetachedFromWindow()以及onDetachedFromWindowInternal()。
4、调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews，需要将当前Window所关联的这三类对象从列表中删除。

Activity的Window创建过程
1、由ActivityThread中的performLaunchActivity()来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用其attach方法为其关联运行过程中所依赖的一系列上下文环境变量。
2、Activity实现了Window的Callback接口，当Window接收到外界的状态变化时就会调用Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等。
3、Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的。 PhoneWindow方法大致遵循如下几个步骤：
    如果没有DecorView，那么就创建它
    将View添加到DecorView的mContentParent中
    回调Activity的onCreateChanged方法通知Activity视图已经发生改变

Dialog的Window创建过程，有如下步骤：
1、创建Window:Diolog中Window的创建同样是通过PolicyManager的makeNewWindow方法来完成的，创建后的对象实际上就是PhoneWindow。
2、初始化DecorView并将Dialog的视图添加到DecorView中
3、将DecorView添加到Window中并显示：普通的Dialog有一个特殊之处，就是必须采用Activity的Context，如果采用Application的Context，那么就会报错。（应用token只有Activity拥有，所以这里只需要Activity作为Context来显示对话框即可）。
service：必须在 Manifest 里面注册系统权限（<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />），在显示 dialog 的时候必须要加一个 flag（WindowManager.LayoutParams.TYPE_SYSTEM_ALERT）

Toast的Window创建过程
1、在Toast的内部有两类IPC过程，第一类是Toast访问NotificationManagerService，第二类是NotificationManagerService回调Toast里的TN接口。
2、Toast属于系统Window，它内部的视图由两种方式指定：一种是系统默认的演示，另一种是通过setView方法来指定一个自定义的View
3、Toast具有定时取消功能，所以系统采用了Handler。Toast的显示和隐藏是IPC过程，都需要NotificationManagerService（NMS）来实现，在Toast和NMS进行IPC过程时，NMS会跨进程回调Toast中的TN类中的方法，TN类是一个Binder类，运行在Binder线程池中，所以需要通过Handler将其切换到当前发送Toast请求所在的线程，所以Toast无法在没有Looper的线程中弹出。
4、对于非系统应用来说，mToastQueue最多能同时存在50个ToastRecord，这样做是为了防止DOS(Denial of Service，拒绝服务)。因为如果某个应用弹出太多的Toast会导致其他应用没有机会弹出Toast。
非UI线程中显示Toast：
        Looper.prepare();  
        Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_SHORT).show();  
        Looper.loop();  

自定义View分为以下4类：
1、继承view重写onDraw方法
2、继承ViewGroup派生特殊的Layout
3、继承特定的View(比如TextView)
4、继承特殊的ViewGroup(比如LinearLayout)

自定义View须知：
1、让View支持wrap_content
2、如果有必要，让你的View支持padding
3、尽量不要在View中使用Handler，没必要
4、View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow
5、View带有滑动嵌套情形时，需要处理好滑动冲突

DOM,SAX,PULL三种解析方式:
DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机
SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。
PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。

JDK 1.7特性
然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(\<>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码

JDK 1.8特性
java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性： 
Lambda 表达式，允许像对象一样传递匿名函数 
Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 
Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 
扩展方法，现在，接口中可以有静态、默认方法。 
重复注解，现在你可以将相同的注解在同一类型上使用多次。

Android 系统中的API：
Formatter.formatFileSize(Context context, long sizeBytes)：格式化文件大小，将字节数据格式化为 B、KB、M 等单位的相应数据
view.performClick()：自动调用 View 点击事件。通常按钮等控件只有在用户点击时才能触发其点击事件
getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE)：设置安全窗口，禁用系统截屏
支付宝 App 的“向商家付款”的包含付款二维码的界面，微信付款界面不是这么做的，采用的是在 onResume() 生命周期方法中实时刷新付款二维码

  @Override
  public void onBackPressed() {
    Intent launcherIntent = new Intent(Intent.ACTION_MAIN);
    launcherIntent.addCategory(Intent.CATEGORY_HOME);
    startActivity(launcherIntent);
  }
  使用 Back 键返回桌面，但不关闭当前应用，而是使之进入后台
缩略图
ThumbnailUtils createVideoThumbnail(String filePath, int kind)/extractThumbnail(Bitmap source, int width, int height)

android:descendantFocusability:用于 ViewGroup 中，解决作为 Parent 的 ViewGroup 与 Children View 之间的焦点占用问题
android:duplicateParentState:是否将 View 自身的 drawable state 交给直接 parent ViewGroup 控制，值为 boolean 类型
android:fillViewport:ScrollView 的一个属性，用于设置内容部分是否填满屏幕，主要针对内容不足以填满屏幕的情况
android:adjustViewBounds:后者需要至少指定 ImageView 宽高中的一个属性，或者 maxHeight 之类的，然后另一个属性随之适配


GridLayoutManager构造方法中传入了一个spanCount,这里值为3
getSpanSize方法中，最后一个item占据2个span，其他占据一个span

一、数字摘要算法：验证消息的完整性，消息摘要采用单向Hash函数将需要计算的内容"摘要"成固定长度的串，其结果总是不同的(相对的)
MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。
SHA的全称是Secure Hash Algorithm，即安全散列算法，是基于MD4算法的，现在已成为公认的最安全的散列算法之一，摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。

二、对称加密：数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。
DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。
3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形
AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。

三、非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。

for与foreach对比
对数组使用foreach语法，实质上转化成普通的for循环实现。而对List使用foreach语法，实质上为Iterator实现，与普通for循环实现完全不同。
所以，实现了RandomAccess的List（例如ArrayList），在遍历的时候使用for循环而不使用foreach。而对于没有实现RandomAccess的List（例如LinkedList），遍历使用Iterator更有效率一点。

Android 唯一设备号生成方案：通过获取到 IMEI、AndroidId、macAddress 进行拼接，再将拼接结果进行 MD5 转换，那么就可以得到一串 32 个字符的 16 进制数据

标记回收算法（Mark and Sweep GC）：从”GC Roots”集合开始，将内存整个遍历一次，保留所有可以被GC Roots直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收，这个算法需要中断进程内其它组件的执行并且可能产生内存碎片

复制算法 (Copying）：将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

标记-压缩算法 (Mark-Compact)：先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

分代：将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。对于新生代适用于复制算法，而对于老年代则采取标记-压缩算法。

复制和标记-压缩算法的区别：
前者是用空间换时间后者则是用时间换空间
前者的在工作的时候是不没有独立的“Mark”与“Copy”阶段的，而是合在一起做一个动作，就叫Scavenge（或Evacuate，或者就叫Copy）。也就是说，每发现一个这次收集中尚未访问过的活对象就直接Copy到新地方，同时设置Forwarding Pointer，这样的工作方式就需要多一份空间。
后者在工作的时候则需要分别的Mark与Compact阶段，Mark阶段用来发现并标记所有活的对象，然后compact阶段才移动对象来达到Compact的目的。如果Compact方式是Sliding Compaction，则在Mark之后就可以按顺序一个个对象“滑动”到空间的某一侧。因为已经先遍历了整个空间里的对象图，知道所有的活对象了，所以移动的时候就可以在同一个空间内而不需要多一份空间。
所以新生代的回收会更快一点，老年代的回收则会需要更长时间，同时压缩阶段是会暂停应用的，所以给我们应该尽量避免对象出现在老年代。

GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。
GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。
GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。
GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。

Android GC 那点事:
https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400021278&idx=1&sn=0e971807eb0e9dcc1a81853189a092f3&scene=0&key=b410d3164f5f798eafd870697d352ac86e0e54b9605b5fcd2c6a62268c16080ee291069627f13ed906cc2f39706b6a54&ascene=0&uin=NzY0MTg2ODU%3D&devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.10.5+build(14F27)&version=11000003&pass_ticket=nhSGhYD4LC9FWvUPv26Y7AdIzqEDu8FTImf2AKlyrCk%3D

ART运行时内部使用的Java堆的主要组成包括Image Space、Zygote Space、Allocation Space和Large Object Space四个Space，Image Space用来存在一些预加载的类， Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的，Large Object Space就是一些离散地址的集合，用来分配一些大对象从而提高了GC的管理效率和整体性能

kGcCauseForAlloc: 当要分配内存的时候发现内存不够的情况下引起的GC，这种情况下的GC会Stop World.
kGcCauseBackground: 当内存达到一定的阀值的时候会去出发GC，这个时候是一个后台GC，不会引起Stop World.
kGcCauseExplicit，显示调用的时候进行的gc，如果ART打开了这个选项的情况下，在system.gc的时候会进行GC.

Alloc内存不够的时候会采用非并发GC，而在Alloc后发现内存达到一定阀值的时候又会触发并发GC

parcel即缓冲区最大1MB，并且这是该进程中所有正在进行中的传输对象所公用的。
parcel传输大小大概是serializable的20倍了。但是官方建议使用Parcel，原因是说速度是serializable的将近10倍

每一个枚举值都是一个对象,在使用它时会增加额外的内存消耗,所以枚举相比与 Integer 和 String 会占用更多的内存。
较多的使用 Enum 会增加 DEX 文件的大小,会造成运行时更多的开销,使我们的应用需要更多的空间。
解决方案：就是要将的@IntDef/@StringDef + @interface来进行限定参数
@IntDef({MAN, WOMEN}) //限定为MAN,WOMEN
@Retention(RetentionPolicy.SOURCE) //表示注解所存活的时间,在运行时,而不会存在. class 文件.

热修复--腾讯：
1、根据Android虚拟机的类加载机制，同一个类只会被加载一次。
2、Android系统通过PathClassLoader来加载系统类和主dex中的类。而DexClassLoader则用于加载其他dex文件中的类。上述两个类都是继承自BaseDexClassLoader，具体的加载方法是findClass
3、加载补丁的思路如下：
    在Application的onCreate()方法中获取应用本身的BaseDexClassLoader,然后通过反射得到对应的dexElements
    创建一个新的DexClassLoader实例，然后加载sdCard上的补丁包，然后通过同样的方法得到对应的dexElements
    将两个dexElements合并，然后再利用反射将合并后的dexElements赋值给应用本身的BaseDexClassLoader
4、
    在apk安装的时候系统会将dex文件优化成odex文件，在优化的过程中会涉及一个预校验的过程
    如果一个类的static方法，private方法，override方法以及构造函数中引用了其他类，而且这些类都属于同一个dex文件，此时该类就会被打上CLASS_ISPREVERIFIED
    如果在运行时被打上CLASS_ISPREVERIFIED的类引用了其他dex的类，就会报错
    所以MainActivity的onCreate()方法中引用另一个dex的类就会出现上文中的问题
    正常的分包方案会保证相关类被打入同一个dex文件
    想要使得patch可以被正常加载，就必须保证类不会被打上CLASS_ISPREVERIFIED标记。而要实现这个目的就必须要在分完包后的class中植入对其他dex文件中类的引用
    要在已经编译完成后的类中植入对其他类的引用，就需要操作字节码，惯用的方案是插桩。常见的工具有javaassist，asm等。


正常App开发过程中，编译，打包过程都是Android Studio自动完成。如无特殊需求无需人为干预，但是要实现插桩就必须在Android Studio的自动化打包流程中加入插桩的过程。

try中的return可以理解为保存了一份副本，即值或对象地址的保存，finally中的更改是更改原先值，return是返回副本
如果try中有return而finally中也有return，那么后者将会让前者失效！

1.subscribeOn影响是整条RxJava链路
2.observeOn只影响它下游的链路
3.连续调用subscribeOn是没有用的,只有第一次会生效
4.连续调用observeOn是有用的,会不断的切换线程。
5.在observeOn调用之后,subscribeOn的影响就会被observeOn抵消。换句话说,observeOn就是subscribeOn的"拦路虎"

目前Android共支持七种不同类型的CPU架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)
    armeabi设备只兼容armeabi；
    armeabi-v7a设备兼容armeabi-v7a、armeabi；
    arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi；
    X86设备兼容X86、armeabi； （x86设备上模拟arm的虚拟层）
    X86_64设备兼容X86_64、X86、armeabi； （x86设备上模拟arm的虚拟层）
    mips64设备兼容mips64、mips；
    mips只兼容mips；

Cow策略：一开始的时候（未复制Zygote进程的地址空间的时候），应用程序进程和Zygote进程共享了同一个用来分配对象的堆。当Zygote进程或者应用程序进程对该堆进行写操作时，内核就会执行真正的拷贝操作，使得Zygote进程和应用程序进程分别拥有自己的一份拷贝，这就是所谓的Cow


https://juejin.im/post/5909c7ef570c3500583bf433

activity singleTask
其实，把启动模式设置为singleTask，framework在启动该activity时只会把它标示为可在一个新任务中启动，至于是否在一个新任务中启动，还要受其他条件的限制
默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的
为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task
任务（Task）不仅可以跨应用（Application），还可以跨进程（Process） 即 运行在同一个任务栈中，运行在不同的进程中
在启动一个singleTask的Activity实例时，如果系统中已经存在这样一个实例，就会将这个实例调度到任务栈的栈顶，并清除它当前所在任务中位于它上面的所有的activity


Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity).我们需要在16ms内完成下一次要刷新的界面的相关运算

Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。
Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
Token的目的是为了验证用户登录情况以及减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

Oauth的认证和授权过程：
1.用户使用第三方的客户端（如访问第三方的网站，或使用第三方的应用），想对存放在服务提供者的某些资源进行操作。
2.第三方网站或应用向服务提供方请求一个临时令牌（Request Token）。
3.服务提供方验证第三方的身份后，授予其一个临时令牌。
4.第三方获得临时令牌后，将用户引导至服务提供方的授权页面请求用户授权。在这个过程中将临时令牌和客户端的回调连接发送给服务提供者。
5.用户在服务提供者的授权页面上输入自己的用户名和密码，然后授权该客户端访问相应的资源。
6.授权成功后，服务提供方引导用户返回第三方网站的的网页。
7.客户端根据临时令牌从服务提供方那里获取访问令牌（Access Token）。
8.服务提供方根据临时令牌和用户的授权情况授予客户端访问令牌。
9.客户端使用获取的访问令牌访问存放在服务提供方上的相应的资源。

微信扫码登录核心过程应该是这样的：浏览器获得一个唯一的、临时的UUID，通过长连接等待客户端扫描带有此UUID的二维码后，从长连接中获得客户端上报给服务器的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。 在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护，类似的应用还有扫码支付、扫码加公众号等功能.

Android进程保活招式大全   http://dev.qq.com/topic/57ac4a0ea374c75371c08ce8
查看当前进程：adb root(如果需要的话) adb shell  ps   cat /proc/{pid}/oom_adj

保持屏幕常亮：
getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
onResume() 和 onPause() 方法中，分别调用这两个方法。

WakeLock 是一个全局的资源，而 FLAG_KEEP_SCREEN_ON 只是一个和 window 相关的资源，作用范围更小了一些。
并且它比 WakeLock 更好的一点在于，它不需要额外的申请权限

布局中的属性 android:keepScreenOn，会在页面的根布局中，添加此属性

自动装箱和自动拆箱：
Integer a = 10;  //实际执行的是Integer a = Integer.valueOf(10);
int b = a;       //实际执行的是int b = a.intValue();
拆箱操作：直接返回Integer内的数值
装箱操作：在i大于IntegerCache.low或者i小于IntegerCache.high时返回缓存的Integer对象，否则创建新的Integer对象。
         Integer在数据为[-128,127]之间时。使用了IntegerCache 返回缓存中对象的引用，否则new一个新的对象
Boolean内部有true&false两个静态变量，最后装箱得到的值都是这两个静态变量的引用。
Long&Integer&Short&Byte在数值为[-128,127]之间都有Cache。
Double&Float则都没有。

map中的移除操作
for (Iterator<Map.Entry<Integer, RouteListener>> it = map.entrySet().iterator(); it.hasNext()
        ; ) {
  Map.Entry<Integer, RouteListener> item = it.next();
  if (item.getValue().equals(listener)) {
    it.remove();
  }
}

Target 
定义了Annotation所修饰的对象范围，取值：　
ElementType.CONSTRUCTOR:用于描述构造器
ElementType.FIELD:用于描述域
ElementType.LOCAL_VARIABLE:用于描述局部变量
ElementType.METHOD:用于描述方法
ElementType.PACKAGE:用于描述包
ElementType.PARAMETER:用于描述参数
ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明

Retention 
定义了该Annotation被保留的时间长短，取值： 
　- RetentionPoicy.SOURCE:注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；用于做一些检查性的操作，比如 @Override 和 @SuppressWarnings 
　- RetentionPoicy.CLASS:注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；用于在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife） 
　- RetentionPoicy.RUNTIME:注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；用于在运行时去动态获取注解信息。 
 
Documented 
标记注解，用于描述其它类型的注解应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化，不用赋值。

Inherited 
标记注解，允许子类继承父类的注解。

如果成员名称是value，在赋值过程中可以简写。如果成员类型为数组，但是只赋值一个元素，则也可以简写。 
1、@Target(value = {ElementType.ANNOTATION_TYPE})
2、@Target({ElementType.ANNOTATION_TYPE})
3、@Target(ElementType.ANNOTATION_TYPE)

Android SDK内置的注解 
资源引用限制类：用于限制参数必须为对应的资源类型 
@AnimRes @AnyRes @ArrayRes @AttrRes @BoolRes @ColorRes等
线程执行限制类：用于限制方法或者类必须在指定的线程执行 
@AnyThread @BinderThread @MainThread @UiThread @WorkerThread
参数为空性限制类：用于限制参数是否可以为空 
@NonNull @Nullable
类型范围限制类：用于限制标注值的值范围 
@FloatRang @IntRange
类型定义类：用于限制定义的注解的取值集合 
@IntDef @StringDef
其他的功能性注解： 
@CallSuper @CheckResult @ColorInt @Dimension @Keep @Px @RequiresApi @RequiresPermission @RestrictTo @Size @VisibleForTesting

原理LeakCanary
当开发者想要检测一个变量是否存在内存泄漏时,直接通过RefWatcher的watch方法来进行监控,然后RefWatcher会为要监控的对象创建一个WeakReference,以及生成一个UUID来作为key表示指定变量,之后会在主线程空闲时在非主线程中判断变量是否存在泄露. 首先移除已经被回收的变量,紧接着判断监控的变量是否在为已经被移除,如果已经移除立即返回,如果没有移除,执行GC然后在判断一次变量是否被回收,如果没有回收,则立即执行dump heap,然后分析heap的使用情况来得到内存泄漏的引用链.

Android6.0权限适配 
如果使用的只是普通权限，也就是不涉及用户隐私的，比如蓝牙，网络访问等，这些权限属于普通权限，普通权限会在应用被安装的时候默认授予，用户不能拒绝，也不能取消
动态权限的申请可以有两种形态，一种是在程序的一开始将所有的权限都申请到，一种是需要的时候再去申请，不需要不申请
 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
 //判断该应用是否有写SD卡权限，如果没有再去申请
     if (ContextCompat.checkSelfPermission(MainActivity.this, permission.WRITE_EXTERNAL_STORAGE) != 
         PackageManager.PERMISSION_GRANTED) {
         ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission
         .WRITE_EXTERNAL_STORAGE}, 123);}
 }
// 调用requestPermissions会弹出对话框，用户做出选择之后的回调
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
//requestCode 是调用requestPermissions传入的123，当然你可以设置成其他值或者某个静态变量

synchronized 详解
互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问
可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。

对象锁：在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。
类锁：在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁

在同一对象的情况下，synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法获取的锁是同一个锁，即该类的对象的对象锁
两个线程访问不同对象的 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法是异步的，同一个类的不同对象的对象锁互不干扰。
在同一对象的情况下，synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法的行为一致。
两个线程访问不同对象的 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法还是同步的，类中 synchronized(类.class) {} 代码块和 synchronized 修饰静态方法获取的锁是类锁。对于同一个类的不同对象的类锁是同一个。
synchronized 修饰静态方法和 synchronized 修饰非静态方法是异步的，对于 synchronized(类.class) {} 代码块和 synchronized(this|object) {} 代码块也是一样的。所以对象锁和类锁是独立的，互不干扰

1、synchronized关键字不能继承。对于父类中的 synchronized 修饰方法，子类在覆盖该方法时，默认情况下不是同步的，必须显示的使用 synchronized 关键字修饰才行。
2、在定义接口方法时不能使用synchronized关键字。
3、构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。

apk签名：
a. 解析出 CERT.RSA 文件中的证书、公钥，解密 CERT.RSA 中的加密数据
b. 解密结果和 CERT.SF 的指纹进行对比，保证 CERT.SF 没有被篡改
c. 而 CERT.SF 中的内容再和 MANIFEST.MF 指纹对比，保证 MANIFEST.MF 文件没有被篡改
d. MANIFEST.MF 中的内容和 APK 所有文件指纹逐一对比，保证 APK 没有被篡改

HashMap：if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
