开启多进程方式：android:process，通过JNI在native层fork一个进程
android:process——默认进程名是包名，
android:process=":xyz"——为包名加+“:xyz”，其为私有进程，其他应用的组件不可以跑在同一进程中
android:process="com.abc"——com.abc，全局进程，其他应用可以通过shareUID方式跑在同一进程
多进程：同一进程的组件属于同一个虚拟机和同一个application，内存空间
1、静态成员变量失效，2、线程同步机制失效，3、SharePreference可靠性下降，4、application多次创建

Parcelable
describeContents方法：通常返回0，效值是CONTENTS_FILE_DESCRIPTOR(0x01)，指明这个Parcel的内容包含文件描述符，文件描述符就是操作文件的数据结构，获取到文件描述符可以完成所有文件相关的操作

Binder
客户端和服务端在同一进程，返回服务端的Stub本身，否则是Stub.proxy对象
最大线程数：15个
死亡代理：linkToDeath，当Binder死亡时，会收到通知
调用服务端/客户端的方法在当前线程中，然后挂起线程，收到返回数据唤醒
被调用的方法在Binder线程池中

文件共享
sharePreferences本身是文件共享，有一定缓存策略，内存中会保存一份缓存，在多进程模式下不可靠

Message
obj：只支持非空的系统实现Parcelable接口数据


AIDL
in：由客户端流向服务端，服务端不能改变客户端
out：服务端流向客户端，服务端改变，客户端改变
inout：双向流通
Dalvik
1、允许有限内存中同时运行多个虚拟机实例，并且每一个Dalvik作为独立进程——防止虚拟机崩溃时，所有程序都被关闭
2、应用每次运行的时候，字节码都需要通过即时编译器转换为机器码
Dalvik监视所有的程序，并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。第一次加载后会生成Cache文件，以提供下次快速加载。
Dalvik解释其采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对接。这样可以节省一个指令后进行查表的时间。

ART 2014androidL
1、应用第一次安装的时候，字节码就预先编译成机器码
2、机器码占用存储空间更大，
3、安装时间变长

Dalvik	执行时编译	安装快	开启慢	占用空间小
ART	安装时编译	安装慢	开启快	占用空间大

service的省电开发
1、查看service是否存活以及降低优先级
2、用IntentService代替Service开发
3、后台执行的定时任务Alarm机制，AndroidL后可以用JobScheduler代替
注意：从Android 4.4之后，Alarm任务的触发时间将会变得不准确
JobScheduler作为一个调度应用程序，负责当应用程序被唤醒时，提供适当的运行环境

网络方面，wifi更省电

TCP：“面向连接”就是在正式通信前必须要与对方建立起连接，一个TCP连接必须要经过三次“对话”才能建立起来
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

Android 沙箱实现了应用程序的相互隔离，用于对文件系统的实体访问进行控制，也可以对其他Android系统资源进行访问控制。
沙箱系统的原理主要基于Linux系统的UID/GID机制
在 Linux 中，一个用户 ID 识别一个给定用户;在 Android 上，一个用户 ID 识别一个应用程序
应用程序在安装时被分配用户 ID，应用程序在设备上的存续期间内，用户 ID 保持不变。权限是关于允许或限制应用程序(而不是用户)访问设备资源
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

浏览器启动app
manifest：
 <intent-filter>
     <action android:name="android.intent.action.VIEW" />

     <category android:name="android.intent.category.DEFAULT" />
     <category android:name="android.intent.category.BROWSABLE" />

     <data android:scheme="wandaappktv" />
 </intent-filter>
 
activity:
Uri uri = intent.getData();
if (uri != null
        && Constants.OVERRIDE_SCHEME.equalsIgnoreCase(uri.getScheme())) {
    String path = uri.toString();
    if (path.startsWith(ACTION_PLAYER)) {
        String callingPackage = intent
                .getStringExtra(ShareCompat.EXTRA_CALLING_PACKAGE);
        String packageName = context.getPackageName();
        if (packageName.equals(callingPackage)) {
chrome
intent:HOST/URI-path // Optional host  
#Intent;  
package=[string];  
action=[string];  
category=[string];  
component=[string];   
scheme=[string];  
end; 
<pre name="code" class="html"><pre name="code" class="html"><a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;end">Do Whatever</a> 
activity:
<activity android:name=".TestUrlScheme" >  
            <intent-filter>  
                <action android:name="android.intent.action.VIEW" /><!-- 显示数据 -->  
                <category android:name="android.intent.category.DEFAULT" />  
                <category android:name="android.intent.category.BROWSABLE" /><!-- 定义成浏览器类型，有URL需要处理时会过滤 -->  
                <data android:scheme="myapp" android:host="whatever" android:path="/" /><!-- 打开以whatever协议的URL,这个自己随便定义。 -->  
            </intent-filter>  
</activity>
传参的内容
<a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;S.name=Perico%20de%20los%20Palotes;I.age=35;end">Do Whatever</a> 
activity:
Bundle parametros = getIntent().getExtras();  
if (extras != null){  
    String name = extras.getString("name");  
    Integer age = extras.getInt("age"); 

android5.0特性
1、Material Design
2、动态替换Theme：在setContentView之前调用setTheme方法；设置了Theme，需要finish当前Activity，然后重启当前Activity，让Theme生效
3、View的高度：elevation用于阴影，translationZ用于属性动画，汇总顺序改为先绘制高度小的，然后再按添加顺序绘制
注意：View的颜色背景为透明，则不会显示出阴影效果；只有子View的大小比父View小时，阴影才能显示出来
4、View的轮廓与剪裁（在Android5.1以上）
outlineProvider：默认是background
none：即使设置了evaluation也不显示阴影
background：按背景来显示轮廓，如果background是颜色值，则轮廓就是view的大小，如果是shape，则按shape指定的形状作为轮廓
bounds: View的矩形大小作轮廓
paddedBounds: View的矩形大小减去padding的值后的大小作轮廓。
注意：如果background是图片，那只能通过代码setOutlineProvider()来指定轮廓
View的裁剪是指将View按照轮廓裁剪，能改变View的形状，先设置轮廓，再设置根据轮廓裁剪View，目前只支持矩形，圆形，圆角矩形的裁剪
5、Palette的使用：从一张图片中拾取颜色
6、水波纹动画，自定义水波纹动画以及状态选择器动画
水波纹动画：在Android5.0以上默认自带
自定义水波纹动画：使用ViewAnimationUtils创建圆形水波纹动画，使用ripple标签或者RippleDrawable可以更改控件水波纹动画颜色
状态选择器动画：通过stateListAnimator属性指定状态选择器的动画
7、CardView的使用：CardLayout拥有高度和阴影，以及轮廓裁剪，圆角等功能
8、RecyclerView的使用
9、ToolBar的使用：用来代替ActionBar，但是比ActionBar更加灵活
10、Android 5.0新特性的向下兼容，通过Support Library使用，使用新API的布局放在res/layout-v21 res/drawable-v21 res/values-v21中

Android 6.0新控件
1、TextInputLayout的使用
2、FloatingActionButton的使用
3、Snackbar的使用
4、TabLayout的使用
5、CoordinatorLayout的使用

1、将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。
2、如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。
3、Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。
第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。

多进程的优势：
1、提高各个进程的稳定性，单一进程崩溃后不影响整个程序。
2、对于内存的时候更可控，可以通过手工释放进程，达到内存优化目的。
3、基于独立的JVM，各个模块可以充分解耦。
4、只保留daemon进程的情况下，会使应用存活时间更长，不容易被回收掉。

空进程存活时长： MAX_EMPTY_TIME = 30min
(缓存+空)进程个数上限：MAX_CACHED_APPS = SystemProperties.getInt(“sys.fw.bg_apps_limit”,32) = 32(默认)；
空进程个数上限：MAX_EMPTY_APPS = computeEmptyProcessLimit(MAX_CACHED_APPS) = MAX_CACHED_APPS/2 = 16；
trim空进程个数上限：TRIM_EMPTY_APPS = computeTrimEmptyApps() = MAX_EMPTY_APPS/2 = 8；
trim缓存进程个数上限：TRIM_CACHED_APPS = computeTrimCachedApps() = MAX_CACHED_APPS-MAX_EMPTY_APPS)/3 = 5;
TRIM_CRITICAL_THRESHOLD = 3;

adj:adj<5的应用不会被杀掉
前台进程0  可感知进程（前台service）2  服务进程（后台service）5  上一个app进程（返回键）7  测试（0 2 7home 9back）
前台进程：
拥有用户正在交互的 Activity（已调用onResume()）
拥有某个 Service，后者绑定到用户正在交互的 Activity
拥有正在“前台”运行的 Service（服务已调用 startForeground()）
拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
拥有正执行其 onReceive() 方法的 BroadcastReceiver

可视进程：
拥有不在前台、但仍对用户可见的 Activity（已调用onPause()）。
拥有绑定到可见（或前台）Activity 的 Service

服务进程：正在运行startService()方法启动的服务，且不属于上述两个更高类别进程的进程。

后台进程：对用户不可见的Activity的进程（已调用Activity的onStop()方法）

空进程：不含任何活动应用组件的进程

进程包括：
前台进程（foreground）可见进程（visible）次要服务（secondary server）后台进程（hidden）内容供应节点（content provider）空进程（empty）

按HOME键，看起来似乎是退出了，但是其实这个软件并没有被关闭，而是转为了后台程序
按退出键，看起来也是退出没错，但这个软件其实是被转为了空置程序
