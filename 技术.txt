ActivityManagerService组织回退栈时以ActivityRecord为基本单位，所有的ActivityRecord放在同一个ArrayList里，可以将mHistory看作一个栈对象，索引0所指的对象位于栈底，索引mHistory.size()-1所指的对象位于栈顶
Zygote进程孵化出新的应用进程后，会执行ActivityThread类的main方法.在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到ActivityManagerService，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。
ActivityThread的main方法执行后,应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法

静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
堆区： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。
堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组

成员变量全部存储与堆中，局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中

在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存

Java内存回收机制：
在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。

强   从来不会      对象的一般状态             jvm停止运行时终止
软   在内存不足时  联合ReferenceQueue构造有   内存不足时终止
                   效期短/内存大/生命周期长
                   的对象二级缓存
弱   在垃圾回收时  联合ReferenceQueue构造有   GC运行后终止
                   效期短/内存大/生命周期长
                   的对象一级缓存
虚   在垃圾回收时  联合ReferenceQueue构造跟   GC运行后终止
                   踪对象被垃圾回收期回收  

开启多进程方式：android:process，通过JNI在native层fork一个进程
android:process——默认进程名是包名，
android:process=":xyz"——为包名加+“:xyz”，其为私有进程，其他应用的组件不可以跑在同一进程中
android:process="com.abc"——com.abc，全局进程，其他应用可以通过shareUID方式跑在同一进程
多进程：同一进程的组件属于同一个虚拟机和同一个application，内存空间
1、静态成员变量失效，2、线程同步机制失效，3、SharePreference可靠性下降，4、application多次创建

Parcelable
describeContents方法：通常返回0，效值是CONTENTS_FILE_DESCRIPTOR(0x01)，指明这个Parcel的内容包含文件描述符，文件描述符就是操作文件的数据结构，获取到文件描述符可以完成所有文件相关的操作

Binder
客户端和服务端在同一进程，返回服务端的Stub本身，否则是Stub.proxy对象
最大线程数：15个
死亡代理：linkToDeath，当Binder死亡时，会收到通知
调用服务端/客户端的方法在当前线程中，然后挂起线程，收到返回数据唤醒
被调用的方法在Binder线程池中

文件共享
sharePreferences本身是文件共享，有一定缓存策略，内存中会保存一份缓存，在多进程模式下不可靠

Message
obj：只支持非空的系统实现Parcelable接口数据


AIDL
in：由客户端流向服务端，服务端不能改变客户端
out：服务端流向客户端，服务端改变，客户端改变
inout：双向流通
Dalvik
1、允许有限内存中同时运行多个虚拟机实例，并且每一个Dalvik作为独立进程——防止虚拟机崩溃时，所有程序都被关闭
2、应用每次运行的时候，字节码都需要通过即时编译器转换为机器码
Dalvik监视所有的程序，并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。第一次加载后会生成Cache文件，以提供下次快速加载。
Dalvik解释其采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对接。这样可以节省一个指令后进行查表的时间。

ART 2014androidL
1、应用第一次安装的时候，字节码就预先编译成机器码
2、机器码占用存储空间更大，
3、安装时间变长

Dalvik	执行时编译	安装快	开启慢	占用空间小
ART	安装时编译	安装慢	开启快	占用空间大

service的省电开发
1、查看service是否存活以及降低优先级
2、用IntentService代替Service开发
3、后台执行的定时任务Alarm机制，AndroidL后可以用JobScheduler代替
注意：从Android 4.4之后，Alarm任务的触发时间将会变得不准确
JobScheduler作为一个调度应用程序，负责当应用程序被唤醒时，提供适当的运行环境

网络方面，wifi更省电

TCP：“面向连接”就是在正式通信前必须要与对方建立起连接，一个TCP连接必须要经过三次“对话”才能建立起来
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

Android 沙箱实现了应用程序的相互隔离，用于对文件系统的实体访问进行控制，也可以对其他Android系统资源进行访问控制。
沙箱系统的原理主要基于Linux系统的UID/GID机制
在 Linux 中，一个用户 ID 识别一个给定用户;在 Android 上，一个用户 ID 识别一个应用程序
应用程序在安装时被分配用户 ID，应用程序在设备上的存续期间内，用户 ID 保持不变。权限是关于允许或限制应用程序(而不是用户)访问设备资源
UDP：“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送

浏览器启动app
manifest：
 <intent-filter>
     <action android:name="android.intent.action.VIEW" />

     <category android:name="android.intent.category.DEFAULT" />
     <category android:name="android.intent.category.BROWSABLE" />

     <data android:scheme="wandaappktv" />
 </intent-filter>
 
activity:
Uri uri = intent.getData();
if (uri != null
        && Constants.OVERRIDE_SCHEME.equalsIgnoreCase(uri.getScheme())) {
    String path = uri.toString();
    if (path.startsWith(ACTION_PLAYER)) {
        String callingPackage = intent
                .getStringExtra(ShareCompat.EXTRA_CALLING_PACKAGE);
        String packageName = context.getPackageName();
        if (packageName.equals(callingPackage)) {
chrome
intent:HOST/URI-path // Optional host  
#Intent;  
package=[string];  
action=[string];  
category=[string];  
component=[string];   
scheme=[string];  
end; 
<pre name="code" class="html"><pre name="code" class="html"><a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;end">Do Whatever</a> 
activity:
<activity android:name=".TestUrlScheme" >  
            <intent-filter>  
                <action android:name="android.intent.action.VIEW" /><!-- 显示数据 -->  
                <category android:name="android.intent.category.DEFAULT" />  
                <category android:name="android.intent.category.BROWSABLE" /><!-- 定义成浏览器类型，有URL需要处理时会过滤 -->  
                <data android:scheme="myapp" android:host="whatever" android:path="/" /><!-- 打开以whatever协议的URL,这个自己随便定义。 -->  
            </intent-filter>  
</activity>
传参的内容
<a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;S.name=Perico%20de%20los%20Palotes;I.age=35;end">Do Whatever</a> 
activity:
Bundle parametros = getIntent().getExtras();  
if (extras != null){  
    String name = extras.getString("name");  
    Integer age = extras.getInt("age"); 

android5.0特性
1、Material Design
2、动态替换Theme：在setContentView之前调用setTheme方法；设置了Theme，需要finish当前Activity，然后重启当前Activity，让Theme生效
3、View的高度：elevation用于阴影，translationZ用于属性动画，汇总顺序改为先绘制高度小的，然后再按添加顺序绘制
注意：View的颜色背景为透明，则不会显示出阴影效果；只有子View的大小比父View小时，阴影才能显示出来
4、View的轮廓与剪裁（在Android5.1以上）
outlineProvider：默认是background
none：即使设置了evaluation也不显示阴影
background：按背景来显示轮廓，如果background是颜色值，则轮廓就是view的大小，如果是shape，则按shape指定的形状作为轮廓
bounds: View的矩形大小作轮廓
paddedBounds: View的矩形大小减去padding的值后的大小作轮廓。
注意：如果background是图片，那只能通过代码setOutlineProvider()来指定轮廓
View的裁剪是指将View按照轮廓裁剪，能改变View的形状，先设置轮廓，再设置根据轮廓裁剪View，目前只支持矩形，圆形，圆角矩形的裁剪
5、Palette的使用：从一张图片中拾取颜色
6、水波纹动画，自定义水波纹动画以及状态选择器动画
水波纹动画：在Android5.0以上默认自带
自定义水波纹动画：使用ViewAnimationUtils创建圆形水波纹动画，使用ripple标签或者RippleDrawable可以更改控件水波纹动画颜色
状态选择器动画：通过stateListAnimator属性指定状态选择器的动画
7、CardView的使用：CardLayout拥有高度和阴影，以及轮廓裁剪，圆角等功能
8、RecyclerView的使用
9、ToolBar的使用：用来代替ActionBar，但是比ActionBar更加灵活
10、Android 5.0新特性的向下兼容，通过Support Library使用，使用新API的布局放在res/layout-v21 res/drawable-v21 res/values-v21中

Android 6.0新控件
1、TextInputLayout的使用
2、FloatingActionButton的使用
3、Snackbar的使用
4、TabLayout的使用
5、CoordinatorLayout的使用

1、将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。
2、如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。
3、Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。
第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。

多进程的优势：
1、提高各个进程的稳定性，单一进程崩溃后不影响整个程序。
2、对于内存的时候更可控，可以通过手工释放进程，达到内存优化目的。
3、基于独立的JVM，各个模块可以充分解耦。
4、只保留daemon进程的情况下，会使应用存活时间更长，不容易被回收掉。

空进程存活时长： MAX_EMPTY_TIME = 30min
(缓存+空)进程个数上限：MAX_CACHED_APPS = SystemProperties.getInt(“sys.fw.bg_apps_limit”,32) = 32(默认)；
空进程个数上限：MAX_EMPTY_APPS = computeEmptyProcessLimit(MAX_CACHED_APPS) = MAX_CACHED_APPS/2 = 16；
trim空进程个数上限：TRIM_EMPTY_APPS = computeTrimEmptyApps() = MAX_EMPTY_APPS/2 = 8；
trim缓存进程个数上限：TRIM_CACHED_APPS = computeTrimCachedApps() = MAX_CACHED_APPS-MAX_EMPTY_APPS)/3 = 5;
TRIM_CRITICAL_THRESHOLD = 3;

adj:adj<5的应用不会被杀掉
前台进程0  可感知进程（前台service）2  服务进程（后台service）5  上一个app进程（返回键）7  测试（0 2 7home 9back）
前台进程：
拥有用户正在交互的 Activity（已调用onResume()）
拥有某个 Service，后者绑定到用户正在交互的 Activity
拥有正在“前台”运行的 Service（服务已调用 startForeground()）
拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
拥有正执行其 onReceive() 方法的 BroadcastReceiver

可视进程：
拥有不在前台、但仍对用户可见的 Activity（已调用onPause()）。
拥有绑定到可见（或前台）Activity 的 Service

服务进程：正在运行startService()方法启动的服务，且不属于上述两个更高类别进程的进程。

后台进程：对用户不可见的Activity的进程（已调用Activity的onStop()方法）

空进程：不含任何活动应用组件的进程

进程包括：
前台进程（foreground）可见进程（visible）次要服务（secondary server）后台进程（hidden）内容供应节点（content provider）空进程（empty）

按HOME键，看起来似乎是退出了，但是其实这个软件并没有被关闭，而是转为了后台程序
按退出键，看起来也是退出没错，但这个软件其实是被转为了空置程序

增量更新
增量更新的流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的）
1、用户手机上提取当前安装应用的apk；2、如何利用old.apk和new.apk生成增量文件；3、增加文件与1.中的old.apk合并，然后安装

manifest 
package：整个应用的包名，通过ComponentName来启动某个Activity
android:sharedUserId="android.uid.system"，将当前应用进程设置为系统级进程，需要在当前模块的MakeFile中添加LOCAL_CERTIFICATE := platform，然后在安卓源码环境下使用原生make命令编译才能生效
uses-permission：为我们的应用添加必须的权限。同时我们也可以该层声明自定义的权限。
  <permission
      android:name="com.cold.permission.appfreeze"
      android:protectionLevel="signatureOrSystem"/>

android:theme：为当前应用的每个界面都默认设置一个主题，可以后续在activity标签层单独覆盖此Theme。
android:allowBackup：关闭应用程序数据的备份和恢复功能，注意该属性值默认为true，如果你不需要你的应用被恢复导致隐私数据暴露
android:hardwareAccelerated：开启硬件加速，一般应用不推介使用。就算非要使用也最好在某个Activity单独开启，避免过大的内存开销。
android:taskAffinity：设置Activity任务栈的名称,可忽略
android:configChanges：当我们的界面大小，方向，字体等config参数改变时，我们的Activity就会重新执行onCreate的生命周期。而当我们设置此属性后，就可以强制让Activity不重新启动，而是只会调用一次onConfigurationChanged方法

intent-filter：当我们通过intent去隐式调用一个Activity时，需要同时匹配注册activity中的action、category、data才能正常启动
action：隐式调用时intent必须setAction。一个过滤器中可以有多个action属性，只要我们的itent和其中任意一项equal则就算匹配成功
category：匹配时也必须和过滤器中定义的值相同，当我们不为intent主动地addCategory时，系统为帮我们默认添加一个值为"android.intent.category.DEFAULT"的category
反过来说，如果我们需要我们自己写的Activity能接受隐式intent启动，我们就必须在它的过滤器中添加"android.intent.category.DEFAULT"（深坑！），否则无法成功启动。
data：分为mimeType和URI路径两部分：mimeType指定媒体格式类型，音频、文件、图片都有特定的属性值。
URI则有android:scheme、android:host、android:port等属性组成，scheme代表模式（常用的有http,content,file,package），Host就是一个主机地址，Port则是端口号。
intent.setDataAndType(Uri.parse("content://com.android.externalstorage.documents"), "vnd.android.document/root");

meta-data：提供组件额外的数据用的，它本身是一个键值对，写在清单文件中之后，可以在代码中获取
android:excludeFromRecents：设置为true后，当用户按了“最近任务列表”时候，该activity不会出现在最近任务列表中，可达到隐藏应用的目的

receiver，permission：可以发送一些敏感的广播，只有添加了该permission的receiver才能接收到，而不让其他的应用收到；不加则所有有此action的接收者都能收到我们发出的广播
Intent intent = new Intent("com.android.settings.action.SWITH_AGED_MODE");
sendBroadcast(intent,"com.android.settings.permission.SWITH_SETTING");


折半查找
        int low = 0;
        int high = sz.length - 1;

        while (low <= high) {
            int middle = (low + high) / 2;
            if(sz[middle] == key){
                return middle;
            }else if(sz[middle] > key){
                high = middle - 1;
            }else {
                low = middle + 1;
            }
        }
        return -1;

jvm：
JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区

程序计数器：一块较小的内存空间，它是当前线程所执行的字节码的行号指示器（么有规定任何OOM）
通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能，每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响

Java虚拟机栈：在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中

GC的两种判定方法：引用计数与引用链
GC的三种收集方法：标记清除、标记整理、复制算法
标记清除：分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。它的主要缺点：1、标记和清除过程效率不高；2、标记清除之后会产生大量不连续的内存碎片。
标记整理：标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。
复制算法，它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。主要缺点：内存缩小为原来的一半。

Window是一个抽象类，它的具体实现是PhoneWindow。WindowManager是外界访问Window的入口，Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的，因此Window实际是View的直接管理者

Window有三种类型，分别是应用Window、子Window和系统Window。
应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。
系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。
